// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// SPDX-License-Identifier: MIT

package core

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"

	"github.com/microsoft/fabric-sdk-go/internal/iruntime"
)

// ConnectionsClient contains the methods for the Connections group.
// Don't use this type directly, use a constructor function instead.
type ConnectionsClient struct {
	internal *azcore.Client
	endpoint string
}

// AddConnectionRoleAssignment - To get the principal user ID required for request body, see Find the user ID [/partner-center/find-ids-and-domain-names#find-the-user-object-id].
// PERMISSIONS
// * The caller must have UserWithReshare or higher role on the connection or be an Admin on the gateway that's bound to the
// connection.
// REQUIRED DELEGATED SCOPES Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - connectionID - The ID of the connection.
//   - addConnectionRoleAssignmentRequest - The request payload for adding a connection role assignment
//   - options - ConnectionsClientAddConnectionRoleAssignmentOptions contains the optional parameters for the ConnectionsClient.AddConnectionRoleAssignment
//     method.
func (client *ConnectionsClient) AddConnectionRoleAssignment(ctx context.Context, connectionID string, addConnectionRoleAssignmentRequest AddConnectionRoleAssignmentRequest, options *ConnectionsClientAddConnectionRoleAssignmentOptions) (ConnectionsClientAddConnectionRoleAssignmentResponse, error) {
	var err error
	const operationName = "core.ConnectionsClient.AddConnectionRoleAssignment"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.addConnectionRoleAssignmentCreateRequest(ctx, connectionID, addConnectionRoleAssignmentRequest, options)
	if err != nil {
		return ConnectionsClientAddConnectionRoleAssignmentResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ConnectionsClientAddConnectionRoleAssignmentResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = NewResponseError(httpResp)
		return ConnectionsClientAddConnectionRoleAssignmentResponse{}, err
	}
	resp, err := client.addConnectionRoleAssignmentHandleResponse(httpResp)
	return resp, err
}

// addConnectionRoleAssignmentCreateRequest creates the AddConnectionRoleAssignment request.
func (client *ConnectionsClient) addConnectionRoleAssignmentCreateRequest(ctx context.Context, connectionID string, addConnectionRoleAssignmentRequest AddConnectionRoleAssignmentRequest, _ *ConnectionsClientAddConnectionRoleAssignmentOptions) (*policy.Request, error) {
	urlPath := "/v1/connections/{connectionId}/roleAssignments"
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, addConnectionRoleAssignmentRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// addConnectionRoleAssignmentHandleResponse handles the AddConnectionRoleAssignment response.
func (client *ConnectionsClient) addConnectionRoleAssignmentHandleResponse(resp *http.Response) (ConnectionsClientAddConnectionRoleAssignmentResponse, error) {
	result := ConnectionsClientAddConnectionRoleAssignmentResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionRoleAssignment); err != nil {
		return ConnectionsClientAddConnectionRoleAssignmentResponse{}, err
	}
	return result, nil
}

// CreateConnection - To encrypt credentials, see Configure credentials programmatically [/power-bi/developer/embedded/configure-credentials].
// PERMISSIONS
// * If creating a gateway connection, the caller must have permissions for the gateway..
// * Service Principals must have permission granted by Fabric administrator. For more information see: Service principals
// can create workspaces, connections, and deployment pipelines
// [/fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines].
// REQUIRED DELEGATED SCOPES Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - createConnectionRequest - The request payload for creating the connection
//   - options - ConnectionsClientCreateConnectionOptions contains the optional parameters for the ConnectionsClient.CreateConnection
//     method.
func (client *ConnectionsClient) CreateConnection(ctx context.Context, createConnectionRequest CreateConnectionRequestClassification, options *ConnectionsClientCreateConnectionOptions) (ConnectionsClientCreateConnectionResponse, error) {
	var err error
	const operationName = "core.ConnectionsClient.CreateConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createConnectionCreateRequest(ctx, createConnectionRequest, options)
	if err != nil {
		return ConnectionsClientCreateConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ConnectionsClientCreateConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = NewResponseError(httpResp)
		return ConnectionsClientCreateConnectionResponse{}, err
	}
	resp, err := client.createConnectionHandleResponse(httpResp)
	return resp, err
}

// createConnectionCreateRequest creates the CreateConnection request.
func (client *ConnectionsClient) createConnectionCreateRequest(ctx context.Context, createConnectionRequest CreateConnectionRequestClassification, _ *ConnectionsClientCreateConnectionOptions) (*policy.Request, error) {
	urlPath := "/v1/connections"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, createConnectionRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// createConnectionHandleResponse handles the CreateConnection response.
func (client *ConnectionsClient) createConnectionHandleResponse(resp *http.Response) (ConnectionsClientCreateConnectionResponse, error) {
	result := ConnectionsClientCreateConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result); err != nil {
		return ConnectionsClientCreateConnectionResponse{}, err
	}
	return result, nil
}

// DeleteConnection - PERMISSIONS The caller must have owner permission for the connection or admin permission for the gateway
// of the connection.
// REQUIRED DELEGATED SCOPES Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - connectionID - The ID of the connection.
//   - options - ConnectionsClientDeleteConnectionOptions contains the optional parameters for the ConnectionsClient.DeleteConnection
//     method.
func (client *ConnectionsClient) DeleteConnection(ctx context.Context, connectionID string, options *ConnectionsClientDeleteConnectionOptions) (ConnectionsClientDeleteConnectionResponse, error) {
	var err error
	const operationName = "core.ConnectionsClient.DeleteConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteConnectionCreateRequest(ctx, connectionID, options)
	if err != nil {
		return ConnectionsClientDeleteConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ConnectionsClientDeleteConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = NewResponseError(httpResp)
		return ConnectionsClientDeleteConnectionResponse{}, err
	}
	return ConnectionsClientDeleteConnectionResponse{}, nil
}

// deleteConnectionCreateRequest creates the DeleteConnection request.
func (client *ConnectionsClient) deleteConnectionCreateRequest(ctx context.Context, connectionID string, _ *ConnectionsClientDeleteConnectionOptions) (*policy.Request, error) {
	urlPath := "/v1/connections/{connectionId}"
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteConnectionRoleAssignment - To get the principal user ID required for request body, see Find the user ID [/partner-center/find-ids-and-domain-names#find-the-user-object-id].
// PERMISSIONS
// * The caller must be an Owner of the connection or be an Admin on the gateway that's bound to the connection.
// REQUIRED DELEGATED SCOPES Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - connectionID - The ID of the connection
//   - connectionRoleAssignmentID - The ID of the role assignment
//   - options - ConnectionsClientDeleteConnectionRoleAssignmentOptions contains the optional parameters for the ConnectionsClient.DeleteConnectionRoleAssignment
//     method.
func (client *ConnectionsClient) DeleteConnectionRoleAssignment(ctx context.Context, connectionID string, connectionRoleAssignmentID string, options *ConnectionsClientDeleteConnectionRoleAssignmentOptions) (ConnectionsClientDeleteConnectionRoleAssignmentResponse, error) {
	var err error
	const operationName = "core.ConnectionsClient.DeleteConnectionRoleAssignment"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteConnectionRoleAssignmentCreateRequest(ctx, connectionID, connectionRoleAssignmentID, options)
	if err != nil {
		return ConnectionsClientDeleteConnectionRoleAssignmentResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ConnectionsClientDeleteConnectionRoleAssignmentResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = NewResponseError(httpResp)
		return ConnectionsClientDeleteConnectionRoleAssignmentResponse{}, err
	}
	return ConnectionsClientDeleteConnectionRoleAssignmentResponse{}, nil
}

// deleteConnectionRoleAssignmentCreateRequest creates the DeleteConnectionRoleAssignment request.
func (client *ConnectionsClient) deleteConnectionRoleAssignmentCreateRequest(ctx context.Context, connectionID string, connectionRoleAssignmentID string, _ *ConnectionsClientDeleteConnectionRoleAssignmentOptions) (*policy.Request, error) {
	urlPath := "/v1/connections/{connectionId}/roleAssignments/{connectionRoleAssignmentId}"
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	if connectionRoleAssignmentID == "" {
		return nil, errors.New("parameter connectionRoleAssignmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionRoleAssignmentId}", url.PathEscape(connectionRoleAssignmentID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetConnection - PERMISSIONS The caller must have permission for the connection or admin permission for the gateway of the
// connection.
// REQUIRED DELEGATED SCOPES Connection.Read.All or Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - connectionID - The ID of the connection.
//   - options - ConnectionsClientGetConnectionOptions contains the optional parameters for the ConnectionsClient.GetConnection
//     method.
func (client *ConnectionsClient) GetConnection(ctx context.Context, connectionID string, options *ConnectionsClientGetConnectionOptions) (ConnectionsClientGetConnectionResponse, error) {
	var err error
	const operationName = "core.ConnectionsClient.GetConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getConnectionCreateRequest(ctx, connectionID, options)
	if err != nil {
		return ConnectionsClientGetConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ConnectionsClientGetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = NewResponseError(httpResp)
		return ConnectionsClientGetConnectionResponse{}, err
	}
	resp, err := client.getConnectionHandleResponse(httpResp)
	return resp, err
}

// getConnectionCreateRequest creates the GetConnection request.
func (client *ConnectionsClient) getConnectionCreateRequest(ctx context.Context, connectionID string, _ *ConnectionsClientGetConnectionOptions) (*policy.Request, error) {
	urlPath := "/v1/connections/{connectionId}"
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConnectionHandleResponse handles the GetConnection response.
func (client *ConnectionsClient) getConnectionHandleResponse(resp *http.Response) (ConnectionsClientGetConnectionResponse, error) {
	result := ConnectionsClientGetConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result); err != nil {
		return ConnectionsClientGetConnectionResponse{}, err
	}
	return result, nil
}

// GetConnectionRoleAssignment - To get the principal user ID required for request body, see Find the user ID [/partner-center/find-ids-and-domain-names#find-the-user-object-id].
// PERMISSIONS
// * The caller must have User or higher role on the connection or be an Admin on the gateway that's bound to the connection.
// REQUIRED DELEGATED SCOPES Connection.Read.All or Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - connectionID - The ID of the connection
//   - connectionRoleAssignmentID - The ID of the connection role assignment
//   - options - ConnectionsClientGetConnectionRoleAssignmentOptions contains the optional parameters for the ConnectionsClient.GetConnectionRoleAssignment
//     method.
func (client *ConnectionsClient) GetConnectionRoleAssignment(ctx context.Context, connectionID string, connectionRoleAssignmentID string, options *ConnectionsClientGetConnectionRoleAssignmentOptions) (ConnectionsClientGetConnectionRoleAssignmentResponse, error) {
	var err error
	const operationName = "core.ConnectionsClient.GetConnectionRoleAssignment"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getConnectionRoleAssignmentCreateRequest(ctx, connectionID, connectionRoleAssignmentID, options)
	if err != nil {
		return ConnectionsClientGetConnectionRoleAssignmentResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ConnectionsClientGetConnectionRoleAssignmentResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = NewResponseError(httpResp)
		return ConnectionsClientGetConnectionRoleAssignmentResponse{}, err
	}
	resp, err := client.getConnectionRoleAssignmentHandleResponse(httpResp)
	return resp, err
}

// getConnectionRoleAssignmentCreateRequest creates the GetConnectionRoleAssignment request.
func (client *ConnectionsClient) getConnectionRoleAssignmentCreateRequest(ctx context.Context, connectionID string, connectionRoleAssignmentID string, _ *ConnectionsClientGetConnectionRoleAssignmentOptions) (*policy.Request, error) {
	urlPath := "/v1/connections/{connectionId}/roleAssignments/{connectionRoleAssignmentId}"
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	if connectionRoleAssignmentID == "" {
		return nil, errors.New("parameter connectionRoleAssignmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionRoleAssignmentId}", url.PathEscape(connectionRoleAssignmentID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getConnectionRoleAssignmentHandleResponse handles the GetConnectionRoleAssignment response.
func (client *ConnectionsClient) getConnectionRoleAssignmentHandleResponse(resp *http.Response) (ConnectionsClientGetConnectionRoleAssignmentResponse, error) {
	result := ConnectionsClientGetConnectionRoleAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionRoleAssignment); err != nil {
		return ConnectionsClientGetConnectionRoleAssignmentResponse{}, err
	}
	return result, nil
}

// NewListConnectionRoleAssignmentsPager - This API supports pagination [/rest/api/fabric/articles/pagination].
// PERMISSIONS
// * The caller must have User or higher role on the connection or be an Admin on the gateway that's bound to the connection.
// REQUIRED DELEGATED SCOPES Connection.Read.All or Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
//
// Generated from API version v1
//   - connectionID - The ID of the connection.
//   - options - ConnectionsClientListConnectionRoleAssignmentsOptions contains the optional parameters for the ConnectionsClient.NewListConnectionRoleAssignmentsPager
//     method.
func (client *ConnectionsClient) NewListConnectionRoleAssignmentsPager(connectionID string, options *ConnectionsClientListConnectionRoleAssignmentsOptions) *runtime.Pager[ConnectionsClientListConnectionRoleAssignmentsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ConnectionsClientListConnectionRoleAssignmentsResponse]{
		More: func(page ConnectionsClientListConnectionRoleAssignmentsResponse) bool {
			return page.ContinuationURI != nil && len(*page.ContinuationURI) > 0
		},
		Fetcher: func(ctx context.Context, page *ConnectionsClientListConnectionRoleAssignmentsResponse) (ConnectionsClientListConnectionRoleAssignmentsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "core.ConnectionsClient.NewListConnectionRoleAssignmentsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.ContinuationURI
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listConnectionRoleAssignmentsCreateRequest(ctx, connectionID, options)
			}, nil)
			if err != nil {
				return ConnectionsClientListConnectionRoleAssignmentsResponse{}, err
			}
			return client.listConnectionRoleAssignmentsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listConnectionRoleAssignmentsCreateRequest creates the ListConnectionRoleAssignments request.
func (client *ConnectionsClient) listConnectionRoleAssignmentsCreateRequest(ctx context.Context, connectionID string, options *ConnectionsClientListConnectionRoleAssignmentsOptions) (*policy.Request, error) {
	urlPath := "/v1/connections/{connectionId}/roleAssignments"
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ContinuationToken != nil {
		reqQP.Set("continuationToken", *options.ContinuationToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConnectionRoleAssignmentsHandleResponse handles the ListConnectionRoleAssignments response.
func (client *ConnectionsClient) listConnectionRoleAssignmentsHandleResponse(resp *http.Response) (ConnectionsClientListConnectionRoleAssignmentsResponse, error) {
	result := ConnectionsClientListConnectionRoleAssignmentsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionRoleAssignments); err != nil {
		return ConnectionsClientListConnectionRoleAssignmentsResponse{}, err
	}
	return result, nil
}

// NewListConnectionsPager - PERMISSIONS The caller must have permission for the connection.
// REQUIRED DELEGATED SCOPES Connection.Read.All or Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
//
// Generated from API version v1
//   - options - ConnectionsClientListConnectionsOptions contains the optional parameters for the ConnectionsClient.NewListConnectionsPager
//     method.
func (client *ConnectionsClient) NewListConnectionsPager(options *ConnectionsClientListConnectionsOptions) *runtime.Pager[ConnectionsClientListConnectionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ConnectionsClientListConnectionsResponse]{
		More: func(page ConnectionsClientListConnectionsResponse) bool {
			return page.ContinuationURI != nil && len(*page.ContinuationURI) > 0
		},
		Fetcher: func(ctx context.Context, page *ConnectionsClientListConnectionsResponse) (ConnectionsClientListConnectionsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "core.ConnectionsClient.NewListConnectionsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.ContinuationURI
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listConnectionsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ConnectionsClientListConnectionsResponse{}, err
			}
			return client.listConnectionsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listConnectionsCreateRequest creates the ListConnections request.
func (client *ConnectionsClient) listConnectionsCreateRequest(ctx context.Context, options *ConnectionsClientListConnectionsOptions) (*policy.Request, error) {
	urlPath := "/v1/connections"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ContinuationToken != nil {
		reqQP.Set("continuationToken", *options.ContinuationToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listConnectionsHandleResponse handles the ListConnections response.
func (client *ConnectionsClient) listConnectionsHandleResponse(resp *http.Response) (ConnectionsClientListConnectionsResponse, error) {
	result := ConnectionsClientListConnectionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ListConnectionsResponse); err != nil {
		return ConnectionsClientListConnectionsResponse{}, err
	}
	return result, nil
}

// NewListSupportedConnectionTypesPager - PERMISSIONS If called with gatewayId, the caller must have permission for the gateway.
// REQUIRED DELEGATED SCOPES Connection.Read.All or Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
//
// Generated from API version v1
//   - options - ConnectionsClientListSupportedConnectionTypesOptions contains the optional parameters for the ConnectionsClient.NewListSupportedConnectionTypesPager
//     method.
func (client *ConnectionsClient) NewListSupportedConnectionTypesPager(options *ConnectionsClientListSupportedConnectionTypesOptions) *runtime.Pager[ConnectionsClientListSupportedConnectionTypesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ConnectionsClientListSupportedConnectionTypesResponse]{
		More: func(page ConnectionsClientListSupportedConnectionTypesResponse) bool {
			return page.ContinuationURI != nil && len(*page.ContinuationURI) > 0
		},
		Fetcher: func(ctx context.Context, page *ConnectionsClientListSupportedConnectionTypesResponse) (ConnectionsClientListSupportedConnectionTypesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "core.ConnectionsClient.NewListSupportedConnectionTypesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.ContinuationURI
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSupportedConnectionTypesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return ConnectionsClientListSupportedConnectionTypesResponse{}, err
			}
			return client.listSupportedConnectionTypesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSupportedConnectionTypesCreateRequest creates the ListSupportedConnectionTypes request.
func (client *ConnectionsClient) listSupportedConnectionTypesCreateRequest(ctx context.Context, options *ConnectionsClientListSupportedConnectionTypesOptions) (*policy.Request, error) {
	urlPath := "/v1/connections/supportedConnectionTypes"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ContinuationToken != nil {
		reqQP.Set("continuationToken", *options.ContinuationToken)
	}
	if options != nil && options.GatewayID != nil {
		reqQP.Set("gatewayId", *options.GatewayID)
	}
	if options != nil && options.ShowAllCreationMethods != nil {
		reqQP.Set("showAllCreationMethods", strconv.FormatBool(*options.ShowAllCreationMethods))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSupportedConnectionTypesHandleResponse handles the ListSupportedConnectionTypes response.
func (client *ConnectionsClient) listSupportedConnectionTypesHandleResponse(resp *http.Response) (ConnectionsClientListSupportedConnectionTypesResponse, error) {
	result := ConnectionsClientListSupportedConnectionTypesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ListSupportedConnectionTypesResponse); err != nil {
		return ConnectionsClientListSupportedConnectionTypesResponse{}, err
	}
	return result, nil
}

// UpdateConnection - To encrypt credentials, see Configure credentials programmatically [/power-bi/developer/embedded/configure-credentials].
// PERMISSIONS The caller must have permission for the connection or admin permission for the gateway of the connection.
// REQUIRED DELEGATED SCOPES Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - connectionID - The ID of the connection.
//   - updateConnectionRequest - The request payload for updating the connection
//   - options - ConnectionsClientUpdateConnectionOptions contains the optional parameters for the ConnectionsClient.UpdateConnection
//     method.
func (client *ConnectionsClient) UpdateConnection(ctx context.Context, connectionID string, updateConnectionRequest UpdateConnectionRequestClassification, options *ConnectionsClientUpdateConnectionOptions) (ConnectionsClientUpdateConnectionResponse, error) {
	var err error
	const operationName = "core.ConnectionsClient.UpdateConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateConnectionCreateRequest(ctx, connectionID, updateConnectionRequest, options)
	if err != nil {
		return ConnectionsClientUpdateConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ConnectionsClientUpdateConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = NewResponseError(httpResp)
		return ConnectionsClientUpdateConnectionResponse{}, err
	}
	resp, err := client.updateConnectionHandleResponse(httpResp)
	return resp, err
}

// updateConnectionCreateRequest creates the UpdateConnection request.
func (client *ConnectionsClient) updateConnectionCreateRequest(ctx context.Context, connectionID string, updateConnectionRequest UpdateConnectionRequestClassification, _ *ConnectionsClientUpdateConnectionOptions) (*policy.Request, error) {
	urlPath := "/v1/connections/{connectionId}"
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, updateConnectionRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// updateConnectionHandleResponse handles the UpdateConnection response.
func (client *ConnectionsClient) updateConnectionHandleResponse(resp *http.Response) (ConnectionsClientUpdateConnectionResponse, error) {
	result := ConnectionsClientUpdateConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result); err != nil {
		return ConnectionsClientUpdateConnectionResponse{}, err
	}
	return result, nil
}

// UpdateConnectionRoleAssignment - To get the principal user ID required for request body, see Find the user ID [/partner-center/find-ids-and-domain-names#find-the-user-object-id].
// PERMISSIONS
// * The caller must be an Owner of the connection or be an Admin on the gateway that's bound to the connection.
// REQUIRED DELEGATED SCOPES Connection.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - connectionID - The ID of the connection
//   - connectionRoleAssignmentID - The ID of the role assignment
//   - updateConnectionRoleAssignmentRequest - Update connection role assignment request payload.
//   - options - ConnectionsClientUpdateConnectionRoleAssignmentOptions contains the optional parameters for the ConnectionsClient.UpdateConnectionRoleAssignment
//     method.
func (client *ConnectionsClient) UpdateConnectionRoleAssignment(ctx context.Context, connectionID string, connectionRoleAssignmentID string, updateConnectionRoleAssignmentRequest UpdateConnectionRoleAssignmentRequest, options *ConnectionsClientUpdateConnectionRoleAssignmentOptions) (ConnectionsClientUpdateConnectionRoleAssignmentResponse, error) {
	var err error
	const operationName = "core.ConnectionsClient.UpdateConnectionRoleAssignment"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateConnectionRoleAssignmentCreateRequest(ctx, connectionID, connectionRoleAssignmentID, updateConnectionRoleAssignmentRequest, options)
	if err != nil {
		return ConnectionsClientUpdateConnectionRoleAssignmentResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ConnectionsClientUpdateConnectionRoleAssignmentResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = NewResponseError(httpResp)
		return ConnectionsClientUpdateConnectionRoleAssignmentResponse{}, err
	}
	resp, err := client.updateConnectionRoleAssignmentHandleResponse(httpResp)
	return resp, err
}

// updateConnectionRoleAssignmentCreateRequest creates the UpdateConnectionRoleAssignment request.
func (client *ConnectionsClient) updateConnectionRoleAssignmentCreateRequest(ctx context.Context, connectionID string, connectionRoleAssignmentID string, updateConnectionRoleAssignmentRequest UpdateConnectionRoleAssignmentRequest, _ *ConnectionsClientUpdateConnectionRoleAssignmentOptions) (*policy.Request, error) {
	urlPath := "/v1/connections/{connectionId}/roleAssignments/{connectionRoleAssignmentId}"
	if connectionID == "" {
		return nil, errors.New("parameter connectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionId}", url.PathEscape(connectionID))
	if connectionRoleAssignmentID == "" {
		return nil, errors.New("parameter connectionRoleAssignmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionRoleAssignmentId}", url.PathEscape(connectionRoleAssignmentID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, updateConnectionRoleAssignmentRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// updateConnectionRoleAssignmentHandleResponse handles the UpdateConnectionRoleAssignment response.
func (client *ConnectionsClient) updateConnectionRoleAssignmentHandleResponse(resp *http.Response) (ConnectionsClientUpdateConnectionRoleAssignmentResponse, error) {
	result := ConnectionsClientUpdateConnectionRoleAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionRoleAssignment); err != nil {
		return ConnectionsClientUpdateConnectionRoleAssignmentResponse{}, err
	}
	return result, nil
}

// Custom code starts below

// ListConnectionRoleAssignments - returns array of ConnectionRoleAssignment from all pages.
// This API supports pagination [/rest/api/fabric/articles/pagination].
//
// PERMISSIONS
//
//   - The caller must have User or higher role on the connection or be an Admin on the gateway that's bound to the connection.
//
// # REQUIRED DELEGATED SCOPES Connection.Read.All or Connection.ReadWrite.All
//
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support] listed in this section.
//
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object] and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
//
// INTERFACE
// Generated from API version v1
//   - connectionID - The ID of the connection.
//   - options - ConnectionsClientListConnectionRoleAssignmentsOptions contains the optional parameters for the ConnectionsClient.NewListConnectionRoleAssignmentsPager method.
func (client *ConnectionsClient) ListConnectionRoleAssignments(ctx context.Context, connectionID string, options *ConnectionsClientListConnectionRoleAssignmentsOptions) ([]ConnectionRoleAssignment, error) {
	pager := client.NewListConnectionRoleAssignmentsPager(connectionID, options)
	mapper := func(resp ConnectionsClientListConnectionRoleAssignmentsResponse) []ConnectionRoleAssignment {
		return resp.Value
	}
	list, err := iruntime.NewPageIterator(ctx, pager, mapper).Get()
	if err != nil {
		var azcoreRespError *azcore.ResponseError
		if errors.As(err, &azcoreRespError) {
			return []ConnectionRoleAssignment{}, NewResponseError(azcoreRespError.RawResponse)
		}
		return []ConnectionRoleAssignment{}, err
	}
	return list, nil
}

// ListConnections - returns array of ConnectionClassification from all pages.
// PERMISSIONS The caller must have permission for the connection.
//
// # REQUIRED DELEGATED SCOPES Connection.Read.All or Connection.ReadWrite.All
//
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support] listed in this section.
//
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object] and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
//
// INTERFACE
// Generated from API version v1
//   - options - ConnectionsClientListConnectionsOptions contains the optional parameters for the ConnectionsClient.NewListConnectionsPager method.
func (client *ConnectionsClient) ListConnections(ctx context.Context, options *ConnectionsClientListConnectionsOptions) ([]ConnectionClassification, error) {
	pager := client.NewListConnectionsPager(options)
	mapper := func(resp ConnectionsClientListConnectionsResponse) []ConnectionClassification {
		return resp.Value
	}
	list, err := iruntime.NewPageIterator(ctx, pager, mapper).Get()
	if err != nil {
		var azcoreRespError *azcore.ResponseError
		if errors.As(err, &azcoreRespError) {
			return []ConnectionClassification{}, NewResponseError(azcoreRespError.RawResponse)
		}
		return []ConnectionClassification{}, err
	}
	return list, nil
}

// ListSupportedConnectionTypes - returns array of ConnectionCreationMetadata from all pages.
// PERMISSIONS If called with gatewayId, the caller must have permission for the gateway.
//
// # REQUIRED DELEGATED SCOPES Connection.Read.All or Connection.ReadWrite.All
//
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support] listed in this section.
//
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object] and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
//
// INTERFACE
// Generated from API version v1
//   - options - ConnectionsClientListSupportedConnectionTypesOptions contains the optional parameters for the ConnectionsClient.NewListSupportedConnectionTypesPager method.
func (client *ConnectionsClient) ListSupportedConnectionTypes(ctx context.Context, options *ConnectionsClientListSupportedConnectionTypesOptions) ([]ConnectionCreationMetadata, error) {
	pager := client.NewListSupportedConnectionTypesPager(options)
	mapper := func(resp ConnectionsClientListSupportedConnectionTypesResponse) []ConnectionCreationMetadata {
		return resp.Value
	}
	list, err := iruntime.NewPageIterator(ctx, pager, mapper).Get()
	if err != nil {
		var azcoreRespError *azcore.ResponseError
		if errors.As(err, &azcoreRespError) {
			return []ConnectionCreationMetadata{}, NewResponseError(azcoreRespError.RawResponse)
		}
		return []ConnectionCreationMetadata{}, err
	}
	return list, nil
}
