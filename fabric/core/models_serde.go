// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// SPDX-License-Identifier: MIT

package core

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// MarshalJSON implements the json.Marshaller interface for type AddConnectionRoleAssignmentRequest.
func (a AddConnectionRoleAssignmentRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principal", a.Principal)
	populate(objectMap, "role", a.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddConnectionRoleAssignmentRequest.
func (a *AddConnectionRoleAssignmentRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principal":
			err = unpopulate(val, "Principal", &a.Principal)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddDeploymentPipelineRoleAssignmentRequest.
func (a AddDeploymentPipelineRoleAssignmentRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principal", a.Principal)
	populate(objectMap, "role", a.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddDeploymentPipelineRoleAssignmentRequest.
func (a *AddDeploymentPipelineRoleAssignmentRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principal":
			err = unpopulate(val, "Principal", &a.Principal)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddGatewayRoleAssignmentRequest.
func (a AddGatewayRoleAssignmentRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principal", a.Principal)
	populate(objectMap, "role", a.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddGatewayRoleAssignmentRequest.
func (a *AddGatewayRoleAssignmentRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principal":
			err = unpopulate(val, "Principal", &a.Principal)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddWorkspaceRoleAssignmentRequest.
func (a AddWorkspaceRoleAssignmentRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principal", a.Principal)
	populate(objectMap, "role", a.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddWorkspaceRoleAssignmentRequest.
func (a *AddWorkspaceRoleAssignmentRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principal":
			err = unpopulate(val, "Principal", &a.Principal)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &a.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AdlsGen2.
func (a AdlsGen2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionId", a.ConnectionID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "subpath", a.Subpath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdlsGen2.
func (a *AdlsGen2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionId":
			err = unpopulate(val, "ConnectionID", &a.ConnectionID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "subpath":
			err = unpopulate(val, "Subpath", &a.Subpath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3.
func (a AmazonS3) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionId", a.ConnectionID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "subpath", a.Subpath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3.
func (a *AmazonS3) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionId":
			err = unpopulate(val, "ConnectionID", &a.ConnectionID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "subpath":
			err = unpopulate(val, "Subpath", &a.Subpath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnonymousCredentials.
func (a AnonymousCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = CredentialTypeAnonymous
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnonymousCredentials.
func (a *AnonymousCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &a.CredentialType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AssignWorkspaceToCapacityRequest.
func (a AssignWorkspaceToCapacityRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityId", a.CapacityID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AssignWorkspaceToCapacityRequest.
func (a *AssignWorkspaceToCapacityRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityId":
			err = unpopulate(val, "CapacityID", &a.CapacityID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomaticGitCredentials.
func (a AutomaticGitCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["source"] = GitCredentialsSourceAutomatic
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomaticGitCredentials.
func (a *AutomaticGitCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "source":
			err = unpopulate(val, "Source", &a.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomaticGitCredentialsResponse.
func (a AutomaticGitCredentialsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["source"] = GitCredentialsSourceAutomatic
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomaticGitCredentialsResponse.
func (a *AutomaticGitCredentialsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "source":
			err = unpopulate(val, "Source", &a.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureDevOpsDetails.
func (a AzureDevOpsDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "branchName", a.BranchName)
	populate(objectMap, "directoryName", a.DirectoryName)
	objectMap["gitProviderType"] = GitProviderTypeAzureDevOps
	populate(objectMap, "organizationName", a.OrganizationName)
	populate(objectMap, "projectName", a.ProjectName)
	populate(objectMap, "repositoryName", a.RepositoryName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDevOpsDetails.
func (a *AzureDevOpsDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "branchName":
			err = unpopulate(val, "BranchName", &a.BranchName)
			delete(rawMsg, key)
		case "directoryName":
			err = unpopulate(val, "DirectoryName", &a.DirectoryName)
			delete(rawMsg, key)
		case "gitProviderType":
			err = unpopulate(val, "GitProviderType", &a.GitProviderType)
			delete(rawMsg, key)
		case "organizationName":
			err = unpopulate(val, "OrganizationName", &a.OrganizationName)
			delete(rawMsg, key)
		case "projectName":
			err = unpopulate(val, "ProjectName", &a.ProjectName)
			delete(rawMsg, key)
		case "repositoryName":
			err = unpopulate(val, "RepositoryName", &a.RepositoryName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BasicCredentials.
func (b BasicCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = CredentialTypeBasic
	populate(objectMap, "password", b.Password)
	populate(objectMap, "username", b.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BasicCredentials.
func (b *BasicCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &b.CredentialType)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &b.Password)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &b.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Capacities.
func (c Capacities) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", c.ContinuationToken)
	populate(objectMap, "continuationUri", c.ContinuationURI)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Capacities.
func (c *Capacities) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &c.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &c.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Capacity.
func (c Capacity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "region", c.Region)
	populate(objectMap, "sku", c.SKU)
	populate(objectMap, "state", c.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Capacity.
func (c *Capacity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, "Region", &c.Region)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, "SKU", &c.SKU)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, "State", &c.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommitToGitRequest.
func (c CommitToGitRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "comment", c.Comment)
	populate(objectMap, "items", c.Items)
	populate(objectMap, "mode", c.Mode)
	populate(objectMap, "workspaceHead", c.WorkspaceHead)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommitToGitRequest.
func (c *CommitToGitRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "comment":
			err = unpopulate(val, "Comment", &c.Comment)
			delete(rawMsg, key)
		case "items":
			err = unpopulate(val, "Items", &c.Items)
			delete(rawMsg, key)
		case "mode":
			err = unpopulate(val, "Mode", &c.Mode)
			delete(rawMsg, key)
		case "workspaceHead":
			err = unpopulate(val, "WorkspaceHead", &c.WorkspaceHead)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConfiguredConnectionGitCredentials.
func (c ConfiguredConnectionGitCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionId", c.ConnectionID)
	objectMap["source"] = GitCredentialsSourceConfiguredConnection
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConfiguredConnectionGitCredentials.
func (c *ConfiguredConnectionGitCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionId":
			err = unpopulate(val, "ConnectionID", &c.ConnectionID)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &c.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConfiguredConnectionGitCredentialsResponse.
func (c ConfiguredConnectionGitCredentialsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionId", c.ConnectionID)
	objectMap["source"] = GitCredentialsSourceConfiguredConnection
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConfiguredConnectionGitCredentialsResponse.
func (c *ConfiguredConnectionGitCredentialsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionId":
			err = unpopulate(val, "ConnectionID", &c.ConnectionID)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &c.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Connection.
func (c Connection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionDetails", c.ConnectionDetails)
	populate(objectMap, "connectivityType", c.ConnectivityType)
	populate(objectMap, "credentialDetails", c.CredentialDetails)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "gatewayId", c.GatewayID)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "privacyLevel", c.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Connection.
func (c *Connection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionDetails":
			err = unpopulate(val, "ConnectionDetails", &c.ConnectionDetails)
			delete(rawMsg, key)
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &c.ConnectivityType)
			delete(rawMsg, key)
		case "credentialDetails":
			err = unpopulate(val, "CredentialDetails", &c.CredentialDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "gatewayId":
			err = unpopulate(val, "GatewayID", &c.GatewayID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &c.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionCreationMetadata.
func (c ConnectionCreationMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "creationMethods", c.CreationMethods)
	populate(objectMap, "supportedConnectionEncryptionTypes", c.SupportedConnectionEncryptionTypes)
	populate(objectMap, "supportedCredentialTypes", c.SupportedCredentialTypes)
	populate(objectMap, "supportsSkipTestConnection", c.SupportsSkipTestConnection)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionCreationMetadata.
func (c *ConnectionCreationMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationMethods":
			err = unpopulate(val, "CreationMethods", &c.CreationMethods)
			delete(rawMsg, key)
		case "supportedConnectionEncryptionTypes":
			err = unpopulate(val, "SupportedConnectionEncryptionTypes", &c.SupportedConnectionEncryptionTypes)
			delete(rawMsg, key)
		case "supportedCredentialTypes":
			err = unpopulate(val, "SupportedCredentialTypes", &c.SupportedCredentialTypes)
			delete(rawMsg, key)
		case "supportsSkipTestConnection":
			err = unpopulate(val, "SupportsSkipTestConnection", &c.SupportsSkipTestConnection)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionCreationMethod.
func (c ConnectionCreationMethod) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "parameters", c.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionCreationMethod.
func (c *ConnectionCreationMethod) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "parameters":
			err = unpopulate(val, "Parameters", &c.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionCreationParameter.
func (c ConnectionCreationParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowedValues", c.AllowedValues)
	populate(objectMap, "dataType", c.DataType)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "required", c.Required)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionCreationParameter.
func (c *ConnectionCreationParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedValues":
			err = unpopulate(val, "AllowedValues", &c.AllowedValues)
			delete(rawMsg, key)
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "required":
			err = unpopulate(val, "Required", &c.Required)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetailsBooleanParameter.
func (c ConnectionDetailsBooleanParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dataType"] = DataTypeBoolean
	populate(objectMap, "name", c.Name)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetailsBooleanParameter.
func (c *ConnectionDetailsBooleanParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetailsDateParameter.
func (c ConnectionDetailsDateParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dataType"] = DataTypeDate
	populate(objectMap, "name", c.Name)
	populateDateType(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetailsDateParameter.
func (c *ConnectionDetailsDateParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulateDateType(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetailsDateTimeParameter.
func (c ConnectionDetailsDateTimeParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dataType"] = DataTypeDateTime
	populate(objectMap, "name", c.Name)
	populateDateTimeRFC3339(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetailsDateTimeParameter.
func (c *ConnectionDetailsDateTimeParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulateDateTimeRFC3339(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetailsDateTimeZoneParameter.
func (c ConnectionDetailsDateTimeZoneParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dataType"] = DataTypeDateTimeZone
	populate(objectMap, "name", c.Name)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetailsDateTimeZoneParameter.
func (c *ConnectionDetailsDateTimeZoneParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetailsDurationParameter.
func (c ConnectionDetailsDurationParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dataType"] = DataTypeDuration
	populate(objectMap, "name", c.Name)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetailsDurationParameter.
func (c *ConnectionDetailsDurationParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetailsNumberParameter.
func (c ConnectionDetailsNumberParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dataType"] = DataTypeNumber
	populate(objectMap, "name", c.Name)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetailsNumberParameter.
func (c *ConnectionDetailsNumberParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetailsParameter.
func (c ConnectionDetailsParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dataType"] = c.DataType
	populate(objectMap, "name", c.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetailsParameter.
func (c *ConnectionDetailsParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetailsTextParameter.
func (c ConnectionDetailsTextParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dataType"] = DataTypeText
	populate(objectMap, "name", c.Name)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetailsTextParameter.
func (c *ConnectionDetailsTextParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionDetailsTimeParameter.
func (c ConnectionDetailsTimeParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["dataType"] = DataTypeTime
	populate(objectMap, "name", c.Name)
	populateTimeRFC3339(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionDetailsTimeParameter.
func (c *ConnectionDetailsTimeParameter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataType":
			err = unpopulate(val, "DataType", &c.DataType)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "value":
			err = unpopulateTimeRFC3339(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionRoleAssignment.
func (c ConnectionRoleAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "principal", c.Principal)
	populate(objectMap, "role", c.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionRoleAssignment.
func (c *ConnectionRoleAssignment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "principal":
			err = unpopulate(val, "Principal", &c.Principal)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &c.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionRoleAssignments.
func (c ConnectionRoleAssignments) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", c.ContinuationToken)
	populate(objectMap, "continuationUri", c.ContinuationURI)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionRoleAssignments.
func (c *ConnectionRoleAssignments) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &c.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &c.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreatableShortcutTarget.
func (c CreatableShortcutTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adlsGen2", c.AdlsGen2)
	populate(objectMap, "amazonS3", c.AmazonS3)
	populate(objectMap, "dataverse", c.Dataverse)
	populate(objectMap, "googleCloudStorage", c.GoogleCloudStorage)
	populate(objectMap, "oneLake", c.OneLake)
	populate(objectMap, "s3Compatible", c.S3Compatible)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreatableShortcutTarget.
func (c *CreatableShortcutTarget) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adlsGen2":
			err = unpopulate(val, "AdlsGen2", &c.AdlsGen2)
			delete(rawMsg, key)
		case "amazonS3":
			err = unpopulate(val, "AmazonS3", &c.AmazonS3)
			delete(rawMsg, key)
		case "dataverse":
			err = unpopulate(val, "Dataverse", &c.Dataverse)
			delete(rawMsg, key)
		case "googleCloudStorage":
			err = unpopulate(val, "GoogleCloudStorage", &c.GoogleCloudStorage)
			delete(rawMsg, key)
		case "oneLake":
			err = unpopulate(val, "OneLake", &c.OneLake)
			delete(rawMsg, key)
		case "s3Compatible":
			err = unpopulate(val, "S3Compatible", &c.S3Compatible)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateCloudConnectionRequest.
func (c CreateCloudConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionDetails", c.ConnectionDetails)
	objectMap["connectivityType"] = ConnectivityTypeShareableCloud
	populate(objectMap, "credentialDetails", c.CredentialDetails)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "privacyLevel", c.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateCloudConnectionRequest.
func (c *CreateCloudConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionDetails":
			err = unpopulate(val, "ConnectionDetails", &c.ConnectionDetails)
			delete(rawMsg, key)
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &c.ConnectivityType)
			delete(rawMsg, key)
		case "credentialDetails":
			err = unpopulate(val, "CredentialDetails", &c.CredentialDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &c.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateConnectionDetails.
func (c CreateConnectionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "creationMethod", c.CreationMethod)
	populate(objectMap, "parameters", c.Parameters)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateConnectionDetails.
func (c *CreateConnectionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationMethod":
			err = unpopulate(val, "CreationMethod", &c.CreationMethod)
			delete(rawMsg, key)
		case "parameters":
			c.Parameters, err = unmarshalConnectionDetailsParameterClassificationArray(val)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateConnectionRequest.
func (c CreateConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionDetails", c.ConnectionDetails)
	objectMap["connectivityType"] = c.ConnectivityType
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "privacyLevel", c.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateConnectionRequest.
func (c *CreateConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionDetails":
			err = unpopulate(val, "ConnectionDetails", &c.ConnectionDetails)
			delete(rawMsg, key)
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &c.ConnectivityType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &c.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateCredentialDetails.
func (c CreateCredentialDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionEncryption", c.ConnectionEncryption)
	populate(objectMap, "credentials", c.Credentials)
	populate(objectMap, "singleSignOnType", c.SingleSignOnType)
	populate(objectMap, "skipTestConnection", c.SkipTestConnection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateCredentialDetails.
func (c *CreateCredentialDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionEncryption":
			err = unpopulate(val, "ConnectionEncryption", &c.ConnectionEncryption)
			delete(rawMsg, key)
		case "credentials":
			c.Credentials, err = unmarshalCredentialsClassification(val)
			delete(rawMsg, key)
		case "singleSignOnType":
			err = unpopulate(val, "SingleSignOnType", &c.SingleSignOnType)
			delete(rawMsg, key)
		case "skipTestConnection":
			err = unpopulate(val, "SkipTestConnection", &c.SkipTestConnection)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateDeploymentPipelineRequest.
func (c CreateDeploymentPipelineRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "stages", c.Stages)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateDeploymentPipelineRequest.
func (c *CreateDeploymentPipelineRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "stages":
			err = unpopulate(val, "Stages", &c.Stages)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateExternalDataShareRequest.
func (c CreateExternalDataShareRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "paths", c.Paths)
	populate(objectMap, "recipient", c.Recipient)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateExternalDataShareRequest.
func (c *CreateExternalDataShareRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "paths":
			err = unpopulate(val, "Paths", &c.Paths)
			delete(rawMsg, key)
		case "recipient":
			err = unpopulate(val, "Recipient", &c.Recipient)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateFolderRequest.
func (c CreateFolderRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "parentFolderId", c.ParentFolderID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateFolderRequest.
func (c *CreateFolderRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "parentFolderId":
			err = unpopulate(val, "ParentFolderID", &c.ParentFolderID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateGatewayRequest.
func (c CreateGatewayRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["type"] = c.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateGatewayRequest.
func (c *CreateGatewayRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateItemRequest.
func (c CreateItemRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "creationPayload", c.CreationPayload)
	populate(objectMap, "definition", c.Definition)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "folderId", c.FolderID)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateItemRequest.
func (c *CreateItemRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationPayload":
			err = unpopulate(val, "CreationPayload", &c.CreationPayload)
			delete(rawMsg, key)
		case "definition":
			err = unpopulate(val, "Definition", &c.Definition)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "folderId":
			err = unpopulate(val, "FolderID", &c.FolderID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateManagedPrivateEndpointRequest.
func (c CreateManagedPrivateEndpointRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "requestMessage", c.RequestMessage)
	populate(objectMap, "targetPrivateLinkResourceId", c.TargetPrivateLinkResourceID)
	populate(objectMap, "targetSubresourceType", c.TargetSubresourceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateManagedPrivateEndpointRequest.
func (c *CreateManagedPrivateEndpointRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "requestMessage":
			err = unpopulate(val, "RequestMessage", &c.RequestMessage)
			delete(rawMsg, key)
		case "targetPrivateLinkResourceId":
			err = unpopulate(val, "TargetPrivateLinkResourceID", &c.TargetPrivateLinkResourceID)
			delete(rawMsg, key)
		case "targetSubresourceType":
			err = unpopulate(val, "TargetSubresourceType", &c.TargetSubresourceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateOnPremisesConnectionRequest.
func (c CreateOnPremisesConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionDetails", c.ConnectionDetails)
	objectMap["connectivityType"] = ConnectivityTypeOnPremisesGateway
	populate(objectMap, "credentialDetails", c.CredentialDetails)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "gatewayId", c.GatewayID)
	populate(objectMap, "privacyLevel", c.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateOnPremisesConnectionRequest.
func (c *CreateOnPremisesConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionDetails":
			err = unpopulate(val, "ConnectionDetails", &c.ConnectionDetails)
			delete(rawMsg, key)
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &c.ConnectivityType)
			delete(rawMsg, key)
		case "credentialDetails":
			err = unpopulate(val, "CredentialDetails", &c.CredentialDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "gatewayId":
			err = unpopulate(val, "GatewayID", &c.GatewayID)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &c.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateOnPremisesCredentialDetails.
func (c CreateOnPremisesCredentialDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionEncryption", c.ConnectionEncryption)
	populate(objectMap, "credentials", c.Credentials)
	populate(objectMap, "singleSignOnType", c.SingleSignOnType)
	populate(objectMap, "skipTestConnection", c.SkipTestConnection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateOnPremisesCredentialDetails.
func (c *CreateOnPremisesCredentialDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionEncryption":
			err = unpopulate(val, "ConnectionEncryption", &c.ConnectionEncryption)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &c.Credentials)
			delete(rawMsg, key)
		case "singleSignOnType":
			err = unpopulate(val, "SingleSignOnType", &c.SingleSignOnType)
			delete(rawMsg, key)
		case "skipTestConnection":
			err = unpopulate(val, "SkipTestConnection", &c.SkipTestConnection)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateOrUpdateDataAccessRolesRequest.
func (c CreateOrUpdateDataAccessRolesRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateOrUpdateDataAccessRolesRequest.
func (c *CreateOrUpdateDataAccessRolesRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateScheduleRequest.
func (c CreateScheduleRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "configuration", c.Configuration)
	populate(objectMap, "enabled", c.Enabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateScheduleRequest.
func (c *CreateScheduleRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configuration":
			c.Configuration, err = unmarshalScheduleConfigClassification(val)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, "Enabled", &c.Enabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateShortcutRequest.
func (c CreateShortcutRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "path", c.Path)
	populate(objectMap, "target", c.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateShortcutRequest.
func (c *CreateShortcutRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &c.Path)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &c.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateVirtualNetworkGatewayConnectionRequest.
func (c CreateVirtualNetworkGatewayConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionDetails", c.ConnectionDetails)
	objectMap["connectivityType"] = ConnectivityTypeVirtualNetworkGateway
	populate(objectMap, "credentialDetails", c.CredentialDetails)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "gatewayId", c.GatewayID)
	populate(objectMap, "privacyLevel", c.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateVirtualNetworkGatewayConnectionRequest.
func (c *CreateVirtualNetworkGatewayConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionDetails":
			err = unpopulate(val, "ConnectionDetails", &c.ConnectionDetails)
			delete(rawMsg, key)
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &c.ConnectivityType)
			delete(rawMsg, key)
		case "credentialDetails":
			err = unpopulate(val, "CredentialDetails", &c.CredentialDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "gatewayId":
			err = unpopulate(val, "GatewayID", &c.GatewayID)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &c.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateVirtualNetworkGatewayRequest.
func (c CreateVirtualNetworkGatewayRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityId", c.CapacityID)
	populate(objectMap, "displayName", c.DisplayName)
	populate(objectMap, "inactivityMinutesBeforeSleep", c.InactivityMinutesBeforeSleep)
	populate(objectMap, "numberOfMemberGateways", c.NumberOfMemberGateways)
	objectMap["type"] = GatewayTypeVirtualNetwork
	populate(objectMap, "virtualNetworkAzureResource", c.VirtualNetworkAzureResource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateVirtualNetworkGatewayRequest.
func (c *CreateVirtualNetworkGatewayRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityId":
			err = unpopulate(val, "CapacityID", &c.CapacityID)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		case "inactivityMinutesBeforeSleep":
			err = unpopulate(val, "InactivityMinutesBeforeSleep", &c.InactivityMinutesBeforeSleep)
			delete(rawMsg, key)
		case "numberOfMemberGateways":
			err = unpopulate(val, "NumberOfMemberGateways", &c.NumberOfMemberGateways)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		case "virtualNetworkAzureResource":
			err = unpopulate(val, "VirtualNetworkAzureResource", &c.VirtualNetworkAzureResource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CreateWorkspaceRequest.
func (c CreateWorkspaceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityId", c.CapacityID)
	populate(objectMap, "description", c.Description)
	populate(objectMap, "displayName", c.DisplayName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CreateWorkspaceRequest.
func (c *CreateWorkspaceRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityId":
			err = unpopulate(val, "CapacityID", &c.CapacityID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &c.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &c.DisplayName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Credentials.
func (c Credentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = c.CredentialType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Credentials.
func (c *Credentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &c.CredentialType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CronScheduleConfig.
func (c CronScheduleConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endDateTime", c.EndDateTime)
	populate(objectMap, "interval", c.Interval)
	populate(objectMap, "localTimeZoneId", c.LocalTimeZoneID)
	populateDateTimeRFC3339(objectMap, "startDateTime", c.StartDateTime)
	objectMap["type"] = ScheduleTypeCron
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CronScheduleConfig.
func (c *CronScheduleConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDateTime":
			err = unpopulateDateTimeRFC3339(val, "EndDateTime", &c.EndDateTime)
			delete(rawMsg, key)
		case "interval":
			err = unpopulate(val, "Interval", &c.Interval)
			delete(rawMsg, key)
		case "localTimeZoneId":
			err = unpopulate(val, "LocalTimeZoneID", &c.LocalTimeZoneID)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateDateTimeRFC3339(val, "StartDateTime", &c.StartDateTime)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DailyScheduleConfig.
func (d DailyScheduleConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endDateTime", d.EndDateTime)
	populate(objectMap, "localTimeZoneId", d.LocalTimeZoneID)
	populateDateTimeRFC3339(objectMap, "startDateTime", d.StartDateTime)
	populate(objectMap, "times", d.Times)
	objectMap["type"] = ScheduleTypeDaily
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DailyScheduleConfig.
func (d *DailyScheduleConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDateTime":
			err = unpopulateDateTimeRFC3339(val, "EndDateTime", &d.EndDateTime)
			delete(rawMsg, key)
		case "localTimeZoneId":
			err = unpopulate(val, "LocalTimeZoneID", &d.LocalTimeZoneID)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateDateTimeRFC3339(val, "StartDateTime", &d.StartDateTime)
			delete(rawMsg, key)
		case "times":
			err = unpopulate(val, "Times", &d.Times)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataAccessRole.
func (d DataAccessRole) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "decisionRules", d.DecisionRules)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "members", d.Members)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataAccessRole.
func (d *DataAccessRole) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "decisionRules":
			err = unpopulate(val, "DecisionRules", &d.DecisionRules)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "members":
			err = unpopulate(val, "Members", &d.Members)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataAccessRoles.
func (d DataAccessRoles) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", d.ContinuationToken)
	populate(objectMap, "continuationUri", d.ContinuationURI)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataAccessRoles.
func (d *DataAccessRoles) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &d.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &d.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Dataverse.
func (d Dataverse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionId", d.ConnectionID)
	populate(objectMap, "deltaLakeFolder", d.DeltaLakeFolder)
	populate(objectMap, "environmentDomain", d.EnvironmentDomain)
	populate(objectMap, "tableName", d.TableName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Dataverse.
func (d *Dataverse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionId":
			err = unpopulate(val, "ConnectionID", &d.ConnectionID)
			delete(rawMsg, key)
		case "deltaLakeFolder":
			err = unpopulate(val, "DeltaLakeFolder", &d.DeltaLakeFolder)
			delete(rawMsg, key)
		case "environmentDomain":
			err = unpopulate(val, "EnvironmentDomain", &d.EnvironmentDomain)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, "TableName", &d.TableName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DecisionRule.
func (d DecisionRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "effect", d.Effect)
	populate(objectMap, "permission", d.Permission)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DecisionRule.
func (d *DecisionRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "effect":
			err = unpopulate(val, "Effect", &d.Effect)
			delete(rawMsg, key)
		case "permission":
			err = unpopulate(val, "Permission", &d.Permission)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeployRequest.
func (d DeployRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "createdWorkspaceDetails", d.CreatedWorkspaceDetails)
	populate(objectMap, "items", d.Items)
	populate(objectMap, "note", d.Note)
	populate(objectMap, "options", d.Options)
	populate(objectMap, "sourceStageId", d.SourceStageID)
	populate(objectMap, "targetStageId", d.TargetStageID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeployRequest.
func (d *DeployRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdWorkspaceDetails":
			err = unpopulate(val, "CreatedWorkspaceDetails", &d.CreatedWorkspaceDetails)
			delete(rawMsg, key)
		case "items":
			err = unpopulate(val, "Items", &d.Items)
			delete(rawMsg, key)
		case "note":
			err = unpopulate(val, "Note", &d.Note)
			delete(rawMsg, key)
		case "options":
			err = unpopulate(val, "Options", &d.Options)
			delete(rawMsg, key)
		case "sourceStageId":
			err = unpopulate(val, "SourceStageID", &d.SourceStageID)
			delete(rawMsg, key)
		case "targetStageId":
			err = unpopulate(val, "TargetStageID", &d.TargetStageID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentExecutionPlan.
func (d DeploymentExecutionPlan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "steps", d.Steps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentExecutionPlan.
func (d *DeploymentExecutionPlan) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "steps":
			err = unpopulate(val, "Steps", &d.Steps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentExecutionStep.
func (d DeploymentExecutionStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "error", d.Error)
	populate(objectMap, "index", d.Index)
	populate(objectMap, "preDeploymentDiffState", d.PreDeploymentDiffState)
	populate(objectMap, "sourceAndTarget", d.SourceAndTarget)
	populate(objectMap, "status", d.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentExecutionStep.
func (d *DeploymentExecutionStep) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &d.Error)
			delete(rawMsg, key)
		case "index":
			err = unpopulate(val, "Index", &d.Index)
			delete(rawMsg, key)
		case "preDeploymentDiffState":
			err = unpopulate(val, "PreDeploymentDiffState", &d.PreDeploymentDiffState)
			delete(rawMsg, key)
		case "sourceAndTarget":
			err = unpopulate(val, "SourceAndTarget", &d.SourceAndTarget)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentOptions.
func (d DeploymentOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowCrossRegionDeployment", d.AllowCrossRegionDeployment)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentOptions.
func (d *DeploymentOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowCrossRegionDeployment":
			err = unpopulate(val, "AllowCrossRegionDeployment", &d.AllowCrossRegionDeployment)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipeline.
func (d DeploymentPipeline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "id", d.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipeline.
func (d *DeploymentPipeline) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineAssignWorkspaceRequest.
func (d DeploymentPipelineAssignWorkspaceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "workspaceId", d.WorkspaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineAssignWorkspaceRequest.
func (d *DeploymentPipelineAssignWorkspaceRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &d.WorkspaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineExtendedInfo.
func (d DeploymentPipelineExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "stages", d.Stages)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineExtendedInfo.
func (d *DeploymentPipelineExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "stages":
			err = unpopulate(val, "Stages", &d.Stages)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineNewWorkspaceConfiguration.
func (d DeploymentPipelineNewWorkspaceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityId", d.CapacityID)
	populate(objectMap, "name", d.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineNewWorkspaceConfiguration.
func (d *DeploymentPipelineNewWorkspaceConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityId":
			err = unpopulate(val, "CapacityID", &d.CapacityID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineOperation.
func (d DeploymentPipelineOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "executionEndTime", d.ExecutionEndTime)
	populateDateTimeRFC3339(objectMap, "executionStartTime", d.ExecutionStartTime)
	populate(objectMap, "id", d.ID)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", d.LastUpdatedTime)
	populate(objectMap, "note", d.Note)
	populate(objectMap, "performedBy", d.PerformedBy)
	populate(objectMap, "preDeploymentDiffInformation", d.PreDeploymentDiffInformation)
	populate(objectMap, "sourceStageId", d.SourceStageID)
	populate(objectMap, "status", d.Status)
	populate(objectMap, "targetStageId", d.TargetStageID)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineOperation.
func (d *DeploymentPipelineOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionEndTime":
			err = unpopulateDateTimeRFC3339(val, "ExecutionEndTime", &d.ExecutionEndTime)
			delete(rawMsg, key)
		case "executionStartTime":
			err = unpopulateDateTimeRFC3339(val, "ExecutionStartTime", &d.ExecutionStartTime)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &d.LastUpdatedTime)
			delete(rawMsg, key)
		case "note":
			err = unpopulate(val, "Note", &d.Note)
			delete(rawMsg, key)
		case "performedBy":
			err = unpopulate(val, "PerformedBy", &d.PerformedBy)
			delete(rawMsg, key)
		case "preDeploymentDiffInformation":
			err = unpopulate(val, "PreDeploymentDiffInformation", &d.PreDeploymentDiffInformation)
			delete(rawMsg, key)
		case "sourceStageId":
			err = unpopulate(val, "SourceStageID", &d.SourceStageID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		case "targetStageId":
			err = unpopulate(val, "TargetStageID", &d.TargetStageID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineOperationExtendedInfo.
func (d DeploymentPipelineOperationExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "executionEndTime", d.ExecutionEndTime)
	populate(objectMap, "executionPlan", d.ExecutionPlan)
	populateDateTimeRFC3339(objectMap, "executionStartTime", d.ExecutionStartTime)
	populate(objectMap, "id", d.ID)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTime", d.LastUpdatedTime)
	populate(objectMap, "note", d.Note)
	populate(objectMap, "performedBy", d.PerformedBy)
	populate(objectMap, "preDeploymentDiffInformation", d.PreDeploymentDiffInformation)
	populate(objectMap, "sourceStageId", d.SourceStageID)
	populate(objectMap, "status", d.Status)
	populate(objectMap, "targetStageId", d.TargetStageID)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineOperationExtendedInfo.
func (d *DeploymentPipelineOperationExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionEndTime":
			err = unpopulateDateTimeRFC3339(val, "ExecutionEndTime", &d.ExecutionEndTime)
			delete(rawMsg, key)
		case "executionPlan":
			err = unpopulate(val, "ExecutionPlan", &d.ExecutionPlan)
			delete(rawMsg, key)
		case "executionStartTime":
			err = unpopulateDateTimeRFC3339(val, "ExecutionStartTime", &d.ExecutionStartTime)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTime", &d.LastUpdatedTime)
			delete(rawMsg, key)
		case "note":
			err = unpopulate(val, "Note", &d.Note)
			delete(rawMsg, key)
		case "performedBy":
			err = unpopulate(val, "PerformedBy", &d.PerformedBy)
			delete(rawMsg, key)
		case "preDeploymentDiffInformation":
			err = unpopulate(val, "PreDeploymentDiffInformation", &d.PreDeploymentDiffInformation)
			delete(rawMsg, key)
		case "sourceStageId":
			err = unpopulate(val, "SourceStageID", &d.SourceStageID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &d.Status)
			delete(rawMsg, key)
		case "targetStageId":
			err = unpopulate(val, "TargetStageID", &d.TargetStageID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineOperationNote.
func (d DeploymentPipelineOperationNote) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "content", d.Content)
	populate(objectMap, "isTruncated", d.IsTruncated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineOperationNote.
func (d *DeploymentPipelineOperationNote) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			err = unpopulate(val, "Content", &d.Content)
			delete(rawMsg, key)
		case "isTruncated":
			err = unpopulate(val, "IsTruncated", &d.IsTruncated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineOperations.
func (d DeploymentPipelineOperations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", d.ContinuationToken)
	populate(objectMap, "continuationUri", d.ContinuationURI)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineOperations.
func (d *DeploymentPipelineOperations) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &d.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &d.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineRoleAssignment.
func (d DeploymentPipelineRoleAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principal", d.Principal)
	populate(objectMap, "role", d.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineRoleAssignment.
func (d *DeploymentPipelineRoleAssignment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principal":
			err = unpopulate(val, "Principal", &d.Principal)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &d.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineRoleAssignments.
func (d DeploymentPipelineRoleAssignments) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", d.ContinuationToken)
	populate(objectMap, "continuationUri", d.ContinuationURI)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineRoleAssignments.
func (d *DeploymentPipelineRoleAssignments) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &d.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &d.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineStage.
func (d DeploymentPipelineStage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "isPublic", d.IsPublic)
	populate(objectMap, "order", d.Order)
	populate(objectMap, "workspaceId", d.WorkspaceID)
	populate(objectMap, "workspaceName", d.WorkspaceName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineStage.
func (d *DeploymentPipelineStage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "isPublic":
			err = unpopulate(val, "IsPublic", &d.IsPublic)
			delete(rawMsg, key)
		case "order":
			err = unpopulate(val, "Order", &d.Order)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &d.WorkspaceID)
			delete(rawMsg, key)
		case "workspaceName":
			err = unpopulate(val, "WorkspaceName", &d.WorkspaceName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineStageItem.
func (d DeploymentPipelineStageItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "itemDisplayName", d.ItemDisplayName)
	populate(objectMap, "itemId", d.ItemID)
	populate(objectMap, "itemType", d.ItemType)
	populateDateTimeRFC3339(objectMap, "lastDeploymentTime", d.LastDeploymentTime)
	populate(objectMap, "sourceItemId", d.SourceItemID)
	populate(objectMap, "targetItemId", d.TargetItemID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineStageItem.
func (d *DeploymentPipelineStageItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "itemDisplayName":
			err = unpopulate(val, "ItemDisplayName", &d.ItemDisplayName)
			delete(rawMsg, key)
		case "itemId":
			err = unpopulate(val, "ItemID", &d.ItemID)
			delete(rawMsg, key)
		case "itemType":
			err = unpopulate(val, "ItemType", &d.ItemType)
			delete(rawMsg, key)
		case "lastDeploymentTime":
			err = unpopulateDateTimeRFC3339(val, "LastDeploymentTime", &d.LastDeploymentTime)
			delete(rawMsg, key)
		case "sourceItemId":
			err = unpopulate(val, "SourceItemID", &d.SourceItemID)
			delete(rawMsg, key)
		case "targetItemId":
			err = unpopulate(val, "TargetItemID", &d.TargetItemID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineStageItems.
func (d DeploymentPipelineStageItems) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", d.ContinuationToken)
	populate(objectMap, "continuationUri", d.ContinuationURI)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineStageItems.
func (d *DeploymentPipelineStageItems) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &d.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &d.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineStageRequest.
func (d DeploymentPipelineStageRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", d.Description)
	populate(objectMap, "displayName", d.DisplayName)
	populate(objectMap, "isPublic", d.IsPublic)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineStageRequest.
func (d *DeploymentPipelineStageRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &d.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &d.DisplayName)
			delete(rawMsg, key)
		case "isPublic":
			err = unpopulate(val, "IsPublic", &d.IsPublic)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelineStages.
func (d DeploymentPipelineStages) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", d.ContinuationToken)
	populate(objectMap, "continuationUri", d.ContinuationURI)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelineStages.
func (d *DeploymentPipelineStages) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &d.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &d.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentPipelines.
func (d DeploymentPipelines) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", d.ContinuationToken)
	populate(objectMap, "continuationUri", d.ContinuationURI)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentPipelines.
func (d *DeploymentPipelines) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &d.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &d.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeploymentSourceAndTarget.
func (d DeploymentSourceAndTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "itemType", d.ItemType)
	populate(objectMap, "sourceItemDisplayName", d.SourceItemDisplayName)
	populate(objectMap, "sourceItemId", d.SourceItemID)
	populate(objectMap, "targetItemDisplayName", d.TargetItemDisplayName)
	populate(objectMap, "targetItemId", d.TargetItemID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeploymentSourceAndTarget.
func (d *DeploymentSourceAndTarget) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "itemType":
			err = unpopulate(val, "ItemType", &d.ItemType)
			delete(rawMsg, key)
		case "sourceItemDisplayName":
			err = unpopulate(val, "SourceItemDisplayName", &d.SourceItemDisplayName)
			delete(rawMsg, key)
		case "sourceItemId":
			err = unpopulate(val, "SourceItemID", &d.SourceItemID)
			delete(rawMsg, key)
		case "targetItemDisplayName":
			err = unpopulate(val, "TargetItemDisplayName", &d.TargetItemDisplayName)
			delete(rawMsg, key)
		case "targetItemId":
			err = unpopulate(val, "TargetItemID", &d.TargetItemID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorRelatedResource.
func (e ErrorRelatedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resourceId", e.ResourceID)
	populate(objectMap, "resourceType", e.ResourceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorRelatedResource.
func (e *ErrorRelatedResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceId":
			err = unpopulate(val, "ResourceID", &e.ResourceID)
			delete(rawMsg, key)
		case "resourceType":
			err = unpopulate(val, "ResourceType", &e.ResourceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorCode", e.ErrorCode)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "moreDetails", e.MoreDetails)
	populate(objectMap, "relatedResource", e.RelatedResource)
	populate(objectMap, "requestId", e.RequestID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponse.
func (e *ErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &e.ErrorCode)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "moreDetails":
			err = unpopulate(val, "MoreDetails", &e.MoreDetails)
			delete(rawMsg, key)
		case "relatedResource":
			err = unpopulate(val, "RelatedResource", &e.RelatedResource)
			delete(rawMsg, key)
		case "requestId":
			err = unpopulate(val, "RequestID", &e.RequestID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponseDetails.
func (e ErrorResponseDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errorCode", e.ErrorCode)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "relatedResource", e.RelatedResource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponseDetails.
func (e *ErrorResponseDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorCode":
			err = unpopulate(val, "ErrorCode", &e.ErrorCode)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "relatedResource":
			err = unpopulate(val, "RelatedResource", &e.RelatedResource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalDataShare.
func (e ExternalDataShare) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "acceptedByTenantId", e.AcceptedByTenantID)
	populate(objectMap, "creatorPrincipal", e.CreatorPrincipal)
	populateDateTimeRFC3339(objectMap, "expirationTimeUtc", e.ExpirationTimeUTC)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "invitationUrl", e.InvitationURL)
	populate(objectMap, "itemId", e.ItemID)
	populate(objectMap, "paths", e.Paths)
	populate(objectMap, "recipient", e.Recipient)
	populate(objectMap, "status", e.Status)
	populate(objectMap, "workspaceId", e.WorkspaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalDataShare.
func (e *ExternalDataShare) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "acceptedByTenantId":
			err = unpopulate(val, "AcceptedByTenantID", &e.AcceptedByTenantID)
			delete(rawMsg, key)
		case "creatorPrincipal":
			err = unpopulate(val, "CreatorPrincipal", &e.CreatorPrincipal)
			delete(rawMsg, key)
		case "expirationTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "ExpirationTimeUTC", &e.ExpirationTimeUTC)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "invitationUrl":
			err = unpopulate(val, "InvitationURL", &e.InvitationURL)
			delete(rawMsg, key)
		case "itemId":
			err = unpopulate(val, "ItemID", &e.ItemID)
			delete(rawMsg, key)
		case "paths":
			err = unpopulate(val, "Paths", &e.Paths)
			delete(rawMsg, key)
		case "recipient":
			err = unpopulate(val, "Recipient", &e.Recipient)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &e.WorkspaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalDataShareRecipient.
func (e ExternalDataShareRecipient) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tenantId", e.TenantID)
	populate(objectMap, "userPrincipalName", e.UserPrincipalName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalDataShareRecipient.
func (e *ExternalDataShareRecipient) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tenantId":
			err = unpopulate(val, "TenantID", &e.TenantID)
			delete(rawMsg, key)
		case "userPrincipalName":
			err = unpopulate(val, "UserPrincipalName", &e.UserPrincipalName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalDataShareTarget.
func (e ExternalDataShareTarget) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionId", e.ConnectionID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalDataShareTarget.
func (e *ExternalDataShareTarget) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionId":
			err = unpopulate(val, "ConnectionID", &e.ConnectionID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalDataShares.
func (e ExternalDataShares) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", e.ContinuationToken)
	populate(objectMap, "continuationUri", e.ContinuationURI)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalDataShares.
func (e *ExternalDataShares) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &e.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &e.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FabricItemMember.
func (f FabricItemMember) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "itemAccess", f.ItemAccess)
	populate(objectMap, "sourcePath", f.SourcePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FabricItemMember.
func (f *FabricItemMember) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "itemAccess":
			err = unpopulate(val, "ItemAccess", &f.ItemAccess)
			delete(rawMsg, key)
		case "sourcePath":
			err = unpopulate(val, "SourcePath", &f.SourcePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Folder.
func (f Folder) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", f.DisplayName)
	populate(objectMap, "id", f.ID)
	populate(objectMap, "parentFolderId", f.ParentFolderID)
	populate(objectMap, "workspaceId", f.WorkspaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Folder.
func (f *Folder) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &f.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &f.ID)
			delete(rawMsg, key)
		case "parentFolderId":
			err = unpopulate(val, "ParentFolderID", &f.ParentFolderID)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &f.WorkspaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Folders.
func (f Folders) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", f.ContinuationToken)
	populate(objectMap, "continuationUri", f.ContinuationURI)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Folders.
func (f *Folders) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &f.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &f.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &f.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Gateway.
func (g Gateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	objectMap["type"] = g.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Gateway.
func (g *Gateway) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayRoleAssignment.
func (g GatewayRoleAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "principal", g.Principal)
	populate(objectMap, "role", g.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayRoleAssignment.
func (g *GatewayRoleAssignment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "principal":
			err = unpopulate(val, "Principal", &g.Principal)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &g.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayRoleAssignments.
func (g GatewayRoleAssignments) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", g.ContinuationToken)
	populate(objectMap, "continuationUri", g.ContinuationURI)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayRoleAssignments.
func (g *GatewayRoleAssignments) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &g.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &g.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitConnectRequest.
func (g GitConnectRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gitProviderDetails", g.GitProviderDetails)
	populate(objectMap, "myGitCredentials", g.MyGitCredentials)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitConnectRequest.
func (g *GitConnectRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gitProviderDetails":
			g.GitProviderDetails, err = unmarshalGitProviderDetailsClassification(val)
			delete(rawMsg, key)
		case "myGitCredentials":
			g.MyGitCredentials, err = unmarshalGitCredentialsClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitConnection.
func (g GitConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gitConnectionState", g.GitConnectionState)
	populate(objectMap, "gitProviderDetails", g.GitProviderDetails)
	populate(objectMap, "gitSyncDetails", g.GitSyncDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitConnection.
func (g *GitConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gitConnectionState":
			err = unpopulate(val, "GitConnectionState", &g.GitConnectionState)
			delete(rawMsg, key)
		case "gitProviderDetails":
			g.GitProviderDetails, err = unmarshalGitProviderDetailsClassification(val)
			delete(rawMsg, key)
		case "gitSyncDetails":
			err = unpopulate(val, "GitSyncDetails", &g.GitSyncDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitCredentials.
func (g GitCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["source"] = g.Source
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitCredentials.
func (g *GitCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "source":
			err = unpopulate(val, "Source", &g.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitCredentialsConfigurationResponse.
func (g GitCredentialsConfigurationResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["source"] = g.Source
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitCredentialsConfigurationResponse.
func (g *GitCredentialsConfigurationResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "source":
			err = unpopulate(val, "Source", &g.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitHubDetails.
func (g GitHubDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "branchName", g.BranchName)
	populate(objectMap, "directoryName", g.DirectoryName)
	objectMap["gitProviderType"] = GitProviderTypeGitHub
	populate(objectMap, "ownerName", g.OwnerName)
	populate(objectMap, "repositoryName", g.RepositoryName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitHubDetails.
func (g *GitHubDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "branchName":
			err = unpopulate(val, "BranchName", &g.BranchName)
			delete(rawMsg, key)
		case "directoryName":
			err = unpopulate(val, "DirectoryName", &g.DirectoryName)
			delete(rawMsg, key)
		case "gitProviderType":
			err = unpopulate(val, "GitProviderType", &g.GitProviderType)
			delete(rawMsg, key)
		case "ownerName":
			err = unpopulate(val, "OwnerName", &g.OwnerName)
			delete(rawMsg, key)
		case "repositoryName":
			err = unpopulate(val, "RepositoryName", &g.RepositoryName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitProviderDetails.
func (g GitProviderDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "branchName", g.BranchName)
	populate(objectMap, "directoryName", g.DirectoryName)
	objectMap["gitProviderType"] = g.GitProviderType
	populate(objectMap, "repositoryName", g.RepositoryName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitProviderDetails.
func (g *GitProviderDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "branchName":
			err = unpopulate(val, "BranchName", &g.BranchName)
			delete(rawMsg, key)
		case "directoryName":
			err = unpopulate(val, "DirectoryName", &g.DirectoryName)
			delete(rawMsg, key)
		case "gitProviderType":
			err = unpopulate(val, "GitProviderType", &g.GitProviderType)
			delete(rawMsg, key)
		case "repositoryName":
			err = unpopulate(val, "RepositoryName", &g.RepositoryName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitStatusResponse.
func (g GitStatusResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "changes", g.Changes)
	populate(objectMap, "remoteCommitHash", g.RemoteCommitHash)
	populate(objectMap, "workspaceHead", g.WorkspaceHead)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitStatusResponse.
func (g *GitStatusResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "changes":
			err = unpopulate(val, "Changes", &g.Changes)
			delete(rawMsg, key)
		case "remoteCommitHash":
			err = unpopulate(val, "RemoteCommitHash", &g.RemoteCommitHash)
			delete(rawMsg, key)
		case "workspaceHead":
			err = unpopulate(val, "WorkspaceHead", &g.WorkspaceHead)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitSyncDetails.
func (g GitSyncDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "head", g.Head)
	populateDateTimeRFC3339(objectMap, "lastSyncTime", g.LastSyncTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitSyncDetails.
func (g *GitSyncDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "head":
			err = unpopulate(val, "Head", &g.Head)
			delete(rawMsg, key)
		case "lastSyncTime":
			err = unpopulateDateTimeRFC3339(val, "LastSyncTime", &g.LastSyncTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorage.
func (g GoogleCloudStorage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionId", g.ConnectionID)
	populate(objectMap, "location", g.Location)
	populate(objectMap, "subpath", g.Subpath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorage.
func (g *GoogleCloudStorage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionId":
			err = unpopulate(val, "ConnectionID", &g.ConnectionID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &g.Location)
			delete(rawMsg, key)
		case "subpath":
			err = unpopulate(val, "Subpath", &g.Subpath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InitializeGitConnectionRequest.
func (i InitializeGitConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "initializationStrategy", i.InitializationStrategy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InitializeGitConnectionRequest.
func (i *InitializeGitConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "initializationStrategy":
			err = unpopulate(val, "InitializationStrategy", &i.InitializationStrategy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InitializeGitConnectionResponse.
func (i InitializeGitConnectionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "remoteCommitHash", i.RemoteCommitHash)
	populate(objectMap, "requiredAction", i.RequiredAction)
	populate(objectMap, "workspaceHead", i.WorkspaceHead)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InitializeGitConnectionResponse.
func (i *InitializeGitConnectionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "remoteCommitHash":
			err = unpopulate(val, "RemoteCommitHash", &i.RemoteCommitHash)
			delete(rawMsg, key)
		case "requiredAction":
			err = unpopulate(val, "RequiredAction", &i.RequiredAction)
			delete(rawMsg, key)
		case "workspaceHead":
			err = unpopulate(val, "WorkspaceHead", &i.WorkspaceHead)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Item.
func (i Item) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", i.Description)
	populate(objectMap, "displayName", i.DisplayName)
	populate(objectMap, "folderId", i.FolderID)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "tags", i.Tags)
	populate(objectMap, "type", i.Type)
	populate(objectMap, "workspaceId", i.WorkspaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Item.
func (i *Item) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &i.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &i.DisplayName)
			delete(rawMsg, key)
		case "folderId":
			err = unpopulate(val, "FolderID", &i.FolderID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &i.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &i.Type)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &i.WorkspaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemChange.
func (i ItemChange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "conflictType", i.ConflictType)
	populate(objectMap, "itemMetadata", i.ItemMetadata)
	populate(objectMap, "remoteChange", i.RemoteChange)
	populate(objectMap, "workspaceChange", i.WorkspaceChange)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemChange.
func (i *ItemChange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "conflictType":
			err = unpopulate(val, "ConflictType", &i.ConflictType)
			delete(rawMsg, key)
		case "itemMetadata":
			err = unpopulate(val, "ItemMetadata", &i.ItemMetadata)
			delete(rawMsg, key)
		case "remoteChange":
			err = unpopulate(val, "RemoteChange", &i.RemoteChange)
			delete(rawMsg, key)
		case "workspaceChange":
			err = unpopulate(val, "WorkspaceChange", &i.WorkspaceChange)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemConnection.
func (i ItemConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionDetails", i.ConnectionDetails)
	populate(objectMap, "connectivityType", i.ConnectivityType)
	populate(objectMap, "displayName", i.DisplayName)
	populate(objectMap, "gatewayId", i.GatewayID)
	populate(objectMap, "id", i.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemConnection.
func (i *ItemConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionDetails":
			err = unpopulate(val, "ConnectionDetails", &i.ConnectionDetails)
			delete(rawMsg, key)
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &i.ConnectivityType)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &i.DisplayName)
			delete(rawMsg, key)
		case "gatewayId":
			err = unpopulate(val, "GatewayID", &i.GatewayID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemConnections.
func (i ItemConnections) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", i.ContinuationToken)
	populate(objectMap, "continuationUri", i.ContinuationURI)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemConnections.
func (i *ItemConnections) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &i.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &i.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemDefinition.
func (i ItemDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "format", i.Format)
	populate(objectMap, "parts", i.Parts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemDefinition.
func (i *ItemDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "format":
			err = unpopulate(val, "Format", &i.Format)
			delete(rawMsg, key)
		case "parts":
			err = unpopulate(val, "Parts", &i.Parts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemDefinitionPart.
func (i ItemDefinitionPart) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "path", i.Path)
	populate(objectMap, "payload", i.Payload)
	populate(objectMap, "payloadType", i.PayloadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemDefinitionPart.
func (i *ItemDefinitionPart) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "path":
			err = unpopulate(val, "Path", &i.Path)
			delete(rawMsg, key)
		case "payload":
			err = unpopulate(val, "Payload", &i.Payload)
			delete(rawMsg, key)
		case "payloadType":
			err = unpopulate(val, "PayloadType", &i.PayloadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemDefinitionResponse.
func (i ItemDefinitionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "definition", i.Definition)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemDefinitionResponse.
func (i *ItemDefinitionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "definition":
			err = unpopulate(val, "Definition", &i.Definition)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemDeploymentRequest.
func (i ItemDeploymentRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "itemType", i.ItemType)
	populate(objectMap, "sourceItemId", i.SourceItemID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemDeploymentRequest.
func (i *ItemDeploymentRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "itemType":
			err = unpopulate(val, "ItemType", &i.ItemType)
			delete(rawMsg, key)
		case "sourceItemId":
			err = unpopulate(val, "SourceItemID", &i.SourceItemID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemIdentifier.
func (i ItemIdentifier) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "logicalId", i.LogicalID)
	populate(objectMap, "objectId", i.ObjectID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemIdentifier.
func (i *ItemIdentifier) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "logicalId":
			err = unpopulate(val, "LogicalID", &i.LogicalID)
			delete(rawMsg, key)
		case "objectId":
			err = unpopulate(val, "ObjectID", &i.ObjectID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemJobInstance.
func (i ItemJobInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "endTimeUtc", i.EndTimeUTC)
	populate(objectMap, "failureReason", i.FailureReason)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "invokeType", i.InvokeType)
	populate(objectMap, "itemId", i.ItemID)
	populate(objectMap, "jobType", i.JobType)
	populate(objectMap, "rootActivityId", i.RootActivityID)
	populate(objectMap, "startTimeUtc", i.StartTimeUTC)
	populate(objectMap, "status", i.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemJobInstance.
func (i *ItemJobInstance) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTimeUtc":
			err = unpopulate(val, "EndTimeUTC", &i.EndTimeUTC)
			delete(rawMsg, key)
		case "failureReason":
			err = unpopulate(val, "FailureReason", &i.FailureReason)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "invokeType":
			err = unpopulate(val, "InvokeType", &i.InvokeType)
			delete(rawMsg, key)
		case "itemId":
			err = unpopulate(val, "ItemID", &i.ItemID)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, "JobType", &i.JobType)
			delete(rawMsg, key)
		case "rootActivityId":
			err = unpopulate(val, "RootActivityID", &i.RootActivityID)
			delete(rawMsg, key)
		case "startTimeUtc":
			err = unpopulate(val, "StartTimeUTC", &i.StartTimeUTC)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &i.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemJobInstances.
func (i ItemJobInstances) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", i.ContinuationToken)
	populate(objectMap, "continuationUri", i.ContinuationURI)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemJobInstances.
func (i *ItemJobInstances) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &i.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &i.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemMetadata.
func (i ItemMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", i.DisplayName)
	populate(objectMap, "itemIdentifier", i.ItemIdentifier)
	populate(objectMap, "itemType", i.ItemType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemMetadata.
func (i *ItemMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &i.DisplayName)
			delete(rawMsg, key)
		case "itemIdentifier":
			err = unpopulate(val, "ItemIdentifier", &i.ItemIdentifier)
			delete(rawMsg, key)
		case "itemType":
			err = unpopulate(val, "ItemType", &i.ItemType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemSchedule.
func (i ItemSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "configuration", i.Configuration)
	populateDateTimeRFC3339(objectMap, "createdDateTime", i.CreatedDateTime)
	populate(objectMap, "enabled", i.Enabled)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "owner", i.Owner)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemSchedule.
func (i *ItemSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configuration":
			i.Configuration, err = unmarshalScheduleConfigClassification(val)
			delete(rawMsg, key)
		case "createdDateTime":
			err = unpopulateDateTimeRFC3339(val, "CreatedDateTime", &i.CreatedDateTime)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, "Enabled", &i.Enabled)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "owner":
			err = unpopulate(val, "Owner", &i.Owner)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemSchedules.
func (i ItemSchedules) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", i.ContinuationToken)
	populate(objectMap, "continuationUri", i.ContinuationURI)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemSchedules.
func (i *ItemSchedules) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &i.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &i.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemTag.
func (i ItemTag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", i.DisplayName)
	populate(objectMap, "id", i.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemTag.
func (i *ItemTag) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &i.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Items.
func (i Items) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", i.ContinuationToken)
	populate(objectMap, "continuationUri", i.ContinuationURI)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Items.
func (i *Items) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &i.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &i.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &i.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeyCredentials.
func (k KeyCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = CredentialTypeKey
	populate(objectMap, "key", k.Key)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyCredentials.
func (k *KeyCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &k.CredentialType)
			delete(rawMsg, key)
		case "key":
			err = unpopulate(val, "Key", &k.Key)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListConnectionDetails.
func (l ListConnectionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "path", l.Path)
	populate(objectMap, "type", l.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListConnectionDetails.
func (l *ListConnectionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "path":
			err = unpopulate(val, "Path", &l.Path)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &l.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListConnectionsResponse.
func (l ListConnectionsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", l.ContinuationToken)
	populate(objectMap, "continuationUri", l.ContinuationURI)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListConnectionsResponse.
func (l *ListConnectionsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &l.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &l.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListCredentialDetails.
func (l ListCredentialDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionEncryption", l.ConnectionEncryption)
	populate(objectMap, "credentialType", l.CredentialType)
	populate(objectMap, "singleSignOnType", l.SingleSignOnType)
	populate(objectMap, "skipTestConnection", l.SkipTestConnection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListCredentialDetails.
func (l *ListCredentialDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionEncryption":
			err = unpopulate(val, "ConnectionEncryption", &l.ConnectionEncryption)
			delete(rawMsg, key)
		case "credentialType":
			err = unpopulate(val, "CredentialType", &l.CredentialType)
			delete(rawMsg, key)
		case "singleSignOnType":
			err = unpopulate(val, "SingleSignOnType", &l.SingleSignOnType)
			delete(rawMsg, key)
		case "skipTestConnection":
			err = unpopulate(val, "SkipTestConnection", &l.SkipTestConnection)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListGatewayMembersResponse.
func (l ListGatewayMembersResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", l.ContinuationToken)
	populate(objectMap, "continuationUri", l.ContinuationURI)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListGatewayMembersResponse.
func (l *ListGatewayMembersResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &l.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &l.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListGatewaysResponse.
func (l ListGatewaysResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", l.ContinuationToken)
	populate(objectMap, "continuationUri", l.ContinuationURI)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListGatewaysResponse.
func (l *ListGatewaysResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &l.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &l.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			l.Value, err = unmarshalGatewayClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ListSupportedConnectionTypesResponse.
func (l ListSupportedConnectionTypesResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", l.ContinuationToken)
	populate(objectMap, "continuationUri", l.ContinuationURI)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ListSupportedConnectionTypesResponse.
func (l *ListSupportedConnectionTypesResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &l.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &l.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedPrivateEndpoint.
func (m ManagedPrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionState", m.ConnectionState)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	populate(objectMap, "targetPrivateLinkResourceId", m.TargetPrivateLinkResourceID)
	populate(objectMap, "targetSubresourceType", m.TargetSubresourceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedPrivateEndpoint.
func (m *ManagedPrivateEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionState":
			err = unpopulate(val, "ConnectionState", &m.ConnectionState)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &m.ProvisioningState)
			delete(rawMsg, key)
		case "targetPrivateLinkResourceId":
			err = unpopulate(val, "TargetPrivateLinkResourceID", &m.TargetPrivateLinkResourceID)
			delete(rawMsg, key)
		case "targetSubresourceType":
			err = unpopulate(val, "TargetSubresourceType", &m.TargetSubresourceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedPrivateEndpoints.
func (m ManagedPrivateEndpoints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", m.ContinuationToken)
	populate(objectMap, "continuationUri", m.ContinuationURI)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedPrivateEndpoints.
func (m *ManagedPrivateEndpoints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &m.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &m.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Members.
func (m Members) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fabricItemMembers", m.FabricItemMembers)
	populate(objectMap, "microsoftEntraMembers", m.MicrosoftEntraMembers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Members.
func (m *Members) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fabricItemMembers":
			err = unpopulate(val, "FabricItemMembers", &m.FabricItemMembers)
			delete(rawMsg, key)
		case "microsoftEntraMembers":
			err = unpopulate(val, "MicrosoftEntraMembers", &m.MicrosoftEntraMembers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftEntraMember.
func (m MicrosoftEntraMember) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "objectId", m.ObjectID)
	populate(objectMap, "objectType", m.ObjectType)
	populate(objectMap, "tenantId", m.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftEntraMember.
func (m *MicrosoftEntraMember) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectId":
			err = unpopulate(val, "ObjectID", &m.ObjectID)
			delete(rawMsg, key)
		case "objectType":
			err = unpopulate(val, "ObjectType", &m.ObjectType)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &m.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MoveFolderRequest.
func (m MoveFolderRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "targetFolderId", m.TargetFolderID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MoveFolderRequest.
func (m *MoveFolderRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "targetFolderId":
			err = unpopulate(val, "TargetFolderID", &m.TargetFolderID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NoneGitCredentialsResponse.
func (n NoneGitCredentialsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["source"] = GitCredentialsSourceNone
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NoneGitCredentialsResponse.
func (n *NoneGitCredentialsResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "source":
			err = unpopulate(val, "Source", &n.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesCredentialEntry.
func (o OnPremisesCredentialEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptedCredentials", o.EncryptedCredentials)
	populate(objectMap, "gatewayId", o.GatewayID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesCredentialEntry.
func (o *OnPremisesCredentialEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredentials":
			err = unpopulate(val, "EncryptedCredentials", &o.EncryptedCredentials)
			delete(rawMsg, key)
		case "gatewayId":
			err = unpopulate(val, "GatewayID", &o.GatewayID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesGateway.
func (o OnPremisesGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowCloudConnectionRefresh", o.AllowCloudConnectionRefresh)
	populate(objectMap, "allowCustomConnectors", o.AllowCustomConnectors)
	populate(objectMap, "displayName", o.DisplayName)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "loadBalancingSetting", o.LoadBalancingSetting)
	populate(objectMap, "numberOfMemberGateways", o.NumberOfMemberGateways)
	populate(objectMap, "publicKey", o.PublicKey)
	objectMap["type"] = GatewayTypeOnPremises
	populate(objectMap, "version", o.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesGateway.
func (o *OnPremisesGateway) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowCloudConnectionRefresh":
			err = unpopulate(val, "AllowCloudConnectionRefresh", &o.AllowCloudConnectionRefresh)
			delete(rawMsg, key)
		case "allowCustomConnectors":
			err = unpopulate(val, "AllowCustomConnectors", &o.AllowCustomConnectors)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &o.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "loadBalancingSetting":
			err = unpopulate(val, "LoadBalancingSetting", &o.LoadBalancingSetting)
			delete(rawMsg, key)
		case "numberOfMemberGateways":
			err = unpopulate(val, "NumberOfMemberGateways", &o.NumberOfMemberGateways)
			delete(rawMsg, key)
		case "publicKey":
			err = unpopulate(val, "PublicKey", &o.PublicKey)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &o.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesGatewayCredentials.
func (o OnPremisesGatewayCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "credentialType", o.CredentialType)
	populate(objectMap, "values", o.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesGatewayCredentials.
func (o *OnPremisesGatewayCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &o.CredentialType)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, "Values", &o.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesGatewayMember.
func (o OnPremisesGatewayMember) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", o.DisplayName)
	populate(objectMap, "enabled", o.Enabled)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "publicKey", o.PublicKey)
	populate(objectMap, "version", o.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesGatewayMember.
func (o *OnPremisesGatewayMember) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &o.DisplayName)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, "Enabled", &o.Enabled)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "publicKey":
			err = unpopulate(val, "PublicKey", &o.PublicKey)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &o.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesGatewayPersonal.
func (o OnPremisesGatewayPersonal) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "publicKey", o.PublicKey)
	objectMap["type"] = GatewayTypeOnPremisesPersonal
	populate(objectMap, "version", o.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesGatewayPersonal.
func (o *OnPremisesGatewayPersonal) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "publicKey":
			err = unpopulate(val, "PublicKey", &o.PublicKey)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &o.Type)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, "Version", &o.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OnPremisesGatewayPersonalCredentials.
func (o OnPremisesGatewayPersonalCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "credentialType", o.CredentialType)
	populate(objectMap, "encryptedCredentials", o.EncryptedCredentials)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OnPremisesGatewayPersonalCredentials.
func (o *OnPremisesGatewayPersonalCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &o.CredentialType)
			delete(rawMsg, key)
		case "encryptedCredentials":
			err = unpopulate(val, "EncryptedCredentials", &o.EncryptedCredentials)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OneLake.
func (o OneLake) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "itemId", o.ItemID)
	populate(objectMap, "path", o.Path)
	populate(objectMap, "workspaceId", o.WorkspaceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OneLake.
func (o *OneLake) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "itemId":
			err = unpopulate(val, "ItemID", &o.ItemID)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &o.Path)
			delete(rawMsg, key)
		case "workspaceId":
			err = unpopulate(val, "WorkspaceID", &o.WorkspaceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OneLakeEndpoints.
func (o OneLakeEndpoints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobEndpoint", o.BlobEndpoint)
	populate(objectMap, "dfsEndpoint", o.DfsEndpoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OneLakeEndpoints.
func (o *OneLakeEndpoints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobEndpoint":
			err = unpopulate(val, "BlobEndpoint", &o.BlobEndpoint)
			delete(rawMsg, key)
		case "dfsEndpoint":
			err = unpopulate(val, "DfsEndpoint", &o.DfsEndpoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationState.
func (o OperationState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdTimeUtc", o.CreatedTimeUTC)
	populate(objectMap, "error", o.Error)
	populateDateTimeRFC3339(objectMap, "lastUpdatedTimeUtc", o.LastUpdatedTimeUTC)
	populate(objectMap, "percentComplete", o.PercentComplete)
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationState.
func (o *OperationState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "CreatedTimeUTC", &o.CreatedTimeUTC)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, "Error", &o.Error)
			delete(rawMsg, key)
		case "lastUpdatedTimeUtc":
			err = unpopulateDateTimeRFC3339(val, "LastUpdatedTimeUTC", &o.LastUpdatedTimeUTC)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, "PercentComplete", &o.PercentComplete)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &o.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PermissionScope.
func (p PermissionScope) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "attributeName", p.AttributeName)
	populate(objectMap, "attributeValueIncludedIn", p.AttributeValueIncludedIn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PermissionScope.
func (p *PermissionScope) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributeName":
			err = unpopulate(val, "AttributeName", &p.AttributeName)
			delete(rawMsg, key)
		case "attributeValueIncludedIn":
			err = unpopulate(val, "AttributeValueIncludedIn", &p.AttributeValueIncludedIn)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PreDeploymentDiffInformation.
func (p PreDeploymentDiffInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "differentItemsCount", p.DifferentItemsCount)
	populate(objectMap, "newItemsCount", p.NewItemsCount)
	populate(objectMap, "noDifferenceItemsCount", p.NoDifferenceItemsCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PreDeploymentDiffInformation.
func (p *PreDeploymentDiffInformation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "differentItemsCount":
			err = unpopulate(val, "DifferentItemsCount", &p.DifferentItemsCount)
			delete(rawMsg, key)
		case "newItemsCount":
			err = unpopulate(val, "NewItemsCount", &p.NewItemsCount)
			delete(rawMsg, key)
		case "noDifferenceItemsCount":
			err = unpopulate(val, "NoDifferenceItemsCount", &p.NoDifferenceItemsCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Principal.
func (p Principal) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "groupDetails", p.GroupDetails)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "servicePrincipalDetails", p.ServicePrincipalDetails)
	populate(objectMap, "servicePrincipalProfileDetails", p.ServicePrincipalProfileDetails)
	populate(objectMap, "type", p.Type)
	populate(objectMap, "userDetails", p.UserDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Principal.
func (p *Principal) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &p.DisplayName)
			delete(rawMsg, key)
		case "groupDetails":
			err = unpopulate(val, "GroupDetails", &p.GroupDetails)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "servicePrincipalDetails":
			err = unpopulate(val, "ServicePrincipalDetails", &p.ServicePrincipalDetails)
			delete(rawMsg, key)
		case "servicePrincipalProfileDetails":
			err = unpopulate(val, "ServicePrincipalProfileDetails", &p.ServicePrincipalProfileDetails)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		case "userDetails":
			err = unpopulate(val, "UserDetails", &p.UserDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrincipalGroupDetails.
func (p PrincipalGroupDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groupType", p.GroupType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrincipalGroupDetails.
func (p *PrincipalGroupDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groupType":
			err = unpopulate(val, "GroupType", &p.GroupType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrincipalServicePrincipalDetails.
func (p PrincipalServicePrincipalDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aadAppId", p.AADAppID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrincipalServicePrincipalDetails.
func (p *PrincipalServicePrincipalDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadAppId":
			err = unpopulate(val, "AADAppID", &p.AADAppID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrincipalServicePrincipalProfileDetails.
func (p PrincipalServicePrincipalProfileDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parentPrincipal", p.ParentPrincipal)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrincipalServicePrincipalProfileDetails.
func (p *PrincipalServicePrincipalProfileDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parentPrincipal":
			err = unpopulate(val, "ParentPrincipal", &p.ParentPrincipal)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrincipalUserDetails.
func (p PrincipalUserDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "userPrincipalName", p.UserPrincipalName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrincipalUserDetails.
func (p *PrincipalUserDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "userPrincipalName":
			err = unpopulate(val, "UserPrincipalName", &p.UserPrincipalName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionState.
func (p PrivateEndpointConnectionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionsRequired", p.ActionsRequired)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrivateEndpointConnectionState.
func (p *PrivateEndpointConnectionState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionsRequired":
			err = unpopulate(val, "ActionsRequired", &p.ActionsRequired)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &p.Description)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, "Status", &p.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PublicKey.
func (p PublicKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exponent", p.Exponent)
	populate(objectMap, "modulus", p.Modulus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PublicKey.
func (p *PublicKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exponent":
			err = unpopulate(val, "Exponent", &p.Exponent)
			delete(rawMsg, key)
		case "modulus":
			err = unpopulate(val, "Modulus", &p.Modulus)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RunOnDemandItemJobRequest.
func (r RunOnDemandItemJobRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "executionData", r.ExecutionData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunOnDemandItemJobRequest.
func (r *RunOnDemandItemJobRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionData":
			err = unpopulate(val, "ExecutionData", &r.ExecutionData)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type S3Compatible.
func (s S3Compatible) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bucket", s.Bucket)
	populate(objectMap, "connectionId", s.ConnectionID)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "subpath", s.Subpath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type S3Compatible.
func (s *S3Compatible) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucket":
			err = unpopulate(val, "Bucket", &s.Bucket)
			delete(rawMsg, key)
		case "connectionId":
			err = unpopulate(val, "ConnectionID", &s.ConnectionID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &s.Location)
			delete(rawMsg, key)
		case "subpath":
			err = unpopulate(val, "Subpath", &s.Subpath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleConfig.
func (s ScheduleConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endDateTime", s.EndDateTime)
	populate(objectMap, "localTimeZoneId", s.LocalTimeZoneID)
	populateDateTimeRFC3339(objectMap, "startDateTime", s.StartDateTime)
	objectMap["type"] = s.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleConfig.
func (s *ScheduleConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDateTime":
			err = unpopulateDateTimeRFC3339(val, "EndDateTime", &s.EndDateTime)
			delete(rawMsg, key)
		case "localTimeZoneId":
			err = unpopulate(val, "LocalTimeZoneID", &s.LocalTimeZoneID)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateDateTimeRFC3339(val, "StartDateTime", &s.StartDateTime)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServicePrincipalCredentials.
func (s ServicePrincipalCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = CredentialTypeServicePrincipal
	populate(objectMap, "servicePrincipalClientId", s.ServicePrincipalClientID)
	populate(objectMap, "servicePrincipalSecret", s.ServicePrincipalSecret)
	populate(objectMap, "tenantId", s.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServicePrincipalCredentials.
func (s *ServicePrincipalCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &s.CredentialType)
			delete(rawMsg, key)
		case "servicePrincipalClientId":
			err = unpopulate(val, "ServicePrincipalClientID", &s.ServicePrincipalClientID)
			delete(rawMsg, key)
		case "servicePrincipalSecret":
			err = unpopulate(val, "ServicePrincipalSecret", &s.ServicePrincipalSecret)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, "TenantID", &s.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SharedAccessSignatureCredentials.
func (s SharedAccessSignatureCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = CredentialTypeSharedAccessSignature
	populate(objectMap, "token", s.Token)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SharedAccessSignatureCredentials.
func (s *SharedAccessSignatureCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &s.CredentialType)
			delete(rawMsg, key)
		case "token":
			err = unpopulate(val, "Token", &s.Token)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Shortcut.
func (s Shortcut) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "path", s.Path)
	populate(objectMap, "target", s.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Shortcut.
func (s *Shortcut) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, "Path", &s.Path)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, "Target", &s.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Shortcuts.
func (s Shortcuts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", s.ContinuationToken)
	populate(objectMap, "continuationUri", s.ContinuationURI)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Shortcuts.
func (s *Shortcuts) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &s.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &s.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Tag.
func (t Tag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", t.DisplayName)
	populate(objectMap, "id", t.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Tag.
func (t *Tag) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &t.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Tags.
func (t Tags) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", t.ContinuationToken)
	populate(objectMap, "continuationUri", t.ContinuationURI)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Tags.
func (t *Tags) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &t.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &t.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Target.
func (t Target) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adlsGen2", t.AdlsGen2)
	populate(objectMap, "amazonS3", t.AmazonS3)
	populate(objectMap, "dataverse", t.Dataverse)
	populate(objectMap, "externalDataShare", t.ExternalDataShare)
	populate(objectMap, "googleCloudStorage", t.GoogleCloudStorage)
	populate(objectMap, "oneLake", t.OneLake)
	populate(objectMap, "s3Compatible", t.S3Compatible)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Target.
func (t *Target) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adlsGen2":
			err = unpopulate(val, "AdlsGen2", &t.AdlsGen2)
			delete(rawMsg, key)
		case "amazonS3":
			err = unpopulate(val, "AmazonS3", &t.AmazonS3)
			delete(rawMsg, key)
		case "dataverse":
			err = unpopulate(val, "Dataverse", &t.Dataverse)
			delete(rawMsg, key)
		case "externalDataShare":
			err = unpopulate(val, "ExternalDataShare", &t.ExternalDataShare)
			delete(rawMsg, key)
		case "googleCloudStorage":
			err = unpopulate(val, "GoogleCloudStorage", &t.GoogleCloudStorage)
			delete(rawMsg, key)
		case "oneLake":
			err = unpopulate(val, "OneLake", &t.OneLake)
			delete(rawMsg, key)
		case "s3Compatible":
			err = unpopulate(val, "S3Compatible", &t.S3Compatible)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateConnectionRequest.
func (u UpdateConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["connectivityType"] = u.ConnectivityType
	populate(objectMap, "privacyLevel", u.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateConnectionRequest.
func (u *UpdateConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &u.ConnectivityType)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &u.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateConnectionRoleAssignmentRequest.
func (u UpdateConnectionRoleAssignmentRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "role", u.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateConnectionRoleAssignmentRequest.
func (u *UpdateConnectionRoleAssignmentRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "role":
			err = unpopulate(val, "Role", &u.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateCredentialDetails.
func (u UpdateCredentialDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionEncryption", u.ConnectionEncryption)
	populate(objectMap, "credentials", u.Credentials)
	populate(objectMap, "singleSignOnType", u.SingleSignOnType)
	populate(objectMap, "skipTestConnection", u.SkipTestConnection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateCredentialDetails.
func (u *UpdateCredentialDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionEncryption":
			err = unpopulate(val, "ConnectionEncryption", &u.ConnectionEncryption)
			delete(rawMsg, key)
		case "credentials":
			u.Credentials, err = unmarshalCredentialsClassification(val)
			delete(rawMsg, key)
		case "singleSignOnType":
			err = unpopulate(val, "SingleSignOnType", &u.SingleSignOnType)
			delete(rawMsg, key)
		case "skipTestConnection":
			err = unpopulate(val, "SkipTestConnection", &u.SkipTestConnection)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateDeploymentPipelineRequest.
func (u UpdateDeploymentPipelineRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", u.Description)
	populate(objectMap, "displayName", u.DisplayName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateDeploymentPipelineRequest.
func (u *UpdateDeploymentPipelineRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateFolderRequest.
func (u UpdateFolderRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", u.DisplayName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateFolderRequest.
func (u *UpdateFolderRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateFromGitRequest.
func (u UpdateFromGitRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "conflictResolution", u.ConflictResolution)
	populate(objectMap, "options", u.Options)
	populate(objectMap, "remoteCommitHash", u.RemoteCommitHash)
	populate(objectMap, "workspaceHead", u.WorkspaceHead)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateFromGitRequest.
func (u *UpdateFromGitRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "conflictResolution":
			err = unpopulate(val, "ConflictResolution", &u.ConflictResolution)
			delete(rawMsg, key)
		case "options":
			err = unpopulate(val, "Options", &u.Options)
			delete(rawMsg, key)
		case "remoteCommitHash":
			err = unpopulate(val, "RemoteCommitHash", &u.RemoteCommitHash)
			delete(rawMsg, key)
		case "workspaceHead":
			err = unpopulate(val, "WorkspaceHead", &u.WorkspaceHead)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateGatewayMemberRequest.
func (u UpdateGatewayMemberRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", u.DisplayName)
	populate(objectMap, "enabled", u.Enabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateGatewayMemberRequest.
func (u *UpdateGatewayMemberRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, "Enabled", &u.Enabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateGatewayRequest.
func (u UpdateGatewayRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", u.DisplayName)
	objectMap["type"] = u.Type
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateGatewayRequest.
func (u *UpdateGatewayRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &u.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateGatewayRoleAssignmentRequest.
func (u UpdateGatewayRoleAssignmentRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "role", u.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateGatewayRoleAssignmentRequest.
func (u *UpdateGatewayRoleAssignmentRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "role":
			err = unpopulate(val, "Role", &u.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateGitCredentialsRequest.
func (u UpdateGitCredentialsRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["source"] = u.Source
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateGitCredentialsRequest.
func (u *UpdateGitCredentialsRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "source":
			err = unpopulate(val, "Source", &u.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateGitCredentialsToAutomaticRequest.
func (u UpdateGitCredentialsToAutomaticRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["source"] = GitCredentialsSourceAutomatic
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateGitCredentialsToAutomaticRequest.
func (u *UpdateGitCredentialsToAutomaticRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "source":
			err = unpopulate(val, "Source", &u.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateGitCredentialsToConfiguredConnectionRequest.
func (u UpdateGitCredentialsToConfiguredConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionId", u.ConnectionID)
	objectMap["source"] = GitCredentialsSourceConfiguredConnection
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateGitCredentialsToConfiguredConnectionRequest.
func (u *UpdateGitCredentialsToConfiguredConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionId":
			err = unpopulate(val, "ConnectionID", &u.ConnectionID)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, "Source", &u.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateGitCredentialsToNoneRequest.
func (u UpdateGitCredentialsToNoneRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["source"] = GitCredentialsSourceNone
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateGitCredentialsToNoneRequest.
func (u *UpdateGitCredentialsToNoneRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "source":
			err = unpopulate(val, "Source", &u.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateItemDefinitionRequest.
func (u UpdateItemDefinitionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "definition", u.Definition)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateItemDefinitionRequest.
func (u *UpdateItemDefinitionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "definition":
			err = unpopulate(val, "Definition", &u.Definition)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateItemRequest.
func (u UpdateItemRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", u.Description)
	populate(objectMap, "displayName", u.DisplayName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateItemRequest.
func (u *UpdateItemRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateOnPremisesGatewayConnectionRequest.
func (u UpdateOnPremisesGatewayConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["connectivityType"] = ConnectivityTypeOnPremisesGateway
	populate(objectMap, "credentialDetails", u.CredentialDetails)
	populate(objectMap, "displayName", u.DisplayName)
	populate(objectMap, "privacyLevel", u.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateOnPremisesGatewayConnectionRequest.
func (u *UpdateOnPremisesGatewayConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &u.ConnectivityType)
			delete(rawMsg, key)
		case "credentialDetails":
			err = unpopulate(val, "CredentialDetails", &u.CredentialDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &u.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateOnPremisesGatewayCredentialDetails.
func (u UpdateOnPremisesGatewayCredentialDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionEncryption", u.ConnectionEncryption)
	populate(objectMap, "credentials", u.Credentials)
	populate(objectMap, "singleSignOnType", u.SingleSignOnType)
	populate(objectMap, "skipTestConnection", u.SkipTestConnection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateOnPremisesGatewayCredentialDetails.
func (u *UpdateOnPremisesGatewayCredentialDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionEncryption":
			err = unpopulate(val, "ConnectionEncryption", &u.ConnectionEncryption)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &u.Credentials)
			delete(rawMsg, key)
		case "singleSignOnType":
			err = unpopulate(val, "SingleSignOnType", &u.SingleSignOnType)
			delete(rawMsg, key)
		case "skipTestConnection":
			err = unpopulate(val, "SkipTestConnection", &u.SkipTestConnection)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateOnPremisesGatewayPersonalConnectionRequest.
func (u UpdateOnPremisesGatewayPersonalConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["connectivityType"] = ConnectivityTypeOnPremisesGatewayPersonal
	populate(objectMap, "credentialDetails", u.CredentialDetails)
	populate(objectMap, "privacyLevel", u.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateOnPremisesGatewayPersonalConnectionRequest.
func (u *UpdateOnPremisesGatewayPersonalConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &u.ConnectivityType)
			delete(rawMsg, key)
		case "credentialDetails":
			err = unpopulate(val, "CredentialDetails", &u.CredentialDetails)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &u.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateOnPremisesGatewayPersonalCredentialDetails.
func (u UpdateOnPremisesGatewayPersonalCredentialDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connectionEncryption", u.ConnectionEncryption)
	populate(objectMap, "credentials", u.Credentials)
	populate(objectMap, "singleSignOnType", u.SingleSignOnType)
	populate(objectMap, "skipTestConnection", u.SkipTestConnection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateOnPremisesGatewayPersonalCredentialDetails.
func (u *UpdateOnPremisesGatewayPersonalCredentialDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionEncryption":
			err = unpopulate(val, "ConnectionEncryption", &u.ConnectionEncryption)
			delete(rawMsg, key)
		case "credentials":
			err = unpopulate(val, "Credentials", &u.Credentials)
			delete(rawMsg, key)
		case "singleSignOnType":
			err = unpopulate(val, "SingleSignOnType", &u.SingleSignOnType)
			delete(rawMsg, key)
		case "skipTestConnection":
			err = unpopulate(val, "SkipTestConnection", &u.SkipTestConnection)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateOnPremisesGatewayRequest.
func (u UpdateOnPremisesGatewayRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowCloudConnectionRefresh", u.AllowCloudConnectionRefresh)
	populate(objectMap, "allowCustomConnectors", u.AllowCustomConnectors)
	populate(objectMap, "displayName", u.DisplayName)
	populate(objectMap, "loadBalancingSetting", u.LoadBalancingSetting)
	objectMap["type"] = GatewayTypeOnPremises
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateOnPremisesGatewayRequest.
func (u *UpdateOnPremisesGatewayRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowCloudConnectionRefresh":
			err = unpopulate(val, "AllowCloudConnectionRefresh", &u.AllowCloudConnectionRefresh)
			delete(rawMsg, key)
		case "allowCustomConnectors":
			err = unpopulate(val, "AllowCustomConnectors", &u.AllowCustomConnectors)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "loadBalancingSetting":
			err = unpopulate(val, "LoadBalancingSetting", &u.LoadBalancingSetting)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &u.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateOptions.
func (u UpdateOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowOverrideItems", u.AllowOverrideItems)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateOptions.
func (u *UpdateOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowOverrideItems":
			err = unpopulate(val, "AllowOverrideItems", &u.AllowOverrideItems)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdatePersonalCloudConnectionRequest.
func (u UpdatePersonalCloudConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["connectivityType"] = ConnectivityTypePersonalCloud
	populate(objectMap, "credentialDetails", u.CredentialDetails)
	populate(objectMap, "privacyLevel", u.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdatePersonalCloudConnectionRequest.
func (u *UpdatePersonalCloudConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &u.ConnectivityType)
			delete(rawMsg, key)
		case "credentialDetails":
			err = unpopulate(val, "CredentialDetails", &u.CredentialDetails)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &u.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateScheduleRequest.
func (u UpdateScheduleRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "configuration", u.Configuration)
	populate(objectMap, "enabled", u.Enabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateScheduleRequest.
func (u *UpdateScheduleRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "configuration":
			u.Configuration, err = unmarshalScheduleConfigClassification(val)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, "Enabled", &u.Enabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateShareableCloudConnectionRequest.
func (u UpdateShareableCloudConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["connectivityType"] = ConnectivityTypeShareableCloud
	populate(objectMap, "credentialDetails", u.CredentialDetails)
	populate(objectMap, "displayName", u.DisplayName)
	populate(objectMap, "privacyLevel", u.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateShareableCloudConnectionRequest.
func (u *UpdateShareableCloudConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &u.ConnectivityType)
			delete(rawMsg, key)
		case "credentialDetails":
			err = unpopulate(val, "CredentialDetails", &u.CredentialDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &u.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateVirtualNetworkGatewayConnectionRequest.
func (u UpdateVirtualNetworkGatewayConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["connectivityType"] = ConnectivityTypeVirtualNetworkGateway
	populate(objectMap, "credentialDetails", u.CredentialDetails)
	populate(objectMap, "displayName", u.DisplayName)
	populate(objectMap, "privacyLevel", u.PrivacyLevel)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateVirtualNetworkGatewayConnectionRequest.
func (u *UpdateVirtualNetworkGatewayConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectivityType":
			err = unpopulate(val, "ConnectivityType", &u.ConnectivityType)
			delete(rawMsg, key)
		case "credentialDetails":
			err = unpopulate(val, "CredentialDetails", &u.CredentialDetails)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "privacyLevel":
			err = unpopulate(val, "PrivacyLevel", &u.PrivacyLevel)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateVirtualNetworkGatewayRequest.
func (u UpdateVirtualNetworkGatewayRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityId", u.CapacityID)
	populate(objectMap, "displayName", u.DisplayName)
	populate(objectMap, "inactivityMinutesBeforeSleep", u.InactivityMinutesBeforeSleep)
	populate(objectMap, "numberOfMemberGateways", u.NumberOfMemberGateways)
	objectMap["type"] = GatewayTypeVirtualNetwork
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateVirtualNetworkGatewayRequest.
func (u *UpdateVirtualNetworkGatewayRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityId":
			err = unpopulate(val, "CapacityID", &u.CapacityID)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		case "inactivityMinutesBeforeSleep":
			err = unpopulate(val, "InactivityMinutesBeforeSleep", &u.InactivityMinutesBeforeSleep)
			delete(rawMsg, key)
		case "numberOfMemberGateways":
			err = unpopulate(val, "NumberOfMemberGateways", &u.NumberOfMemberGateways)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &u.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateWorkspaceRequest.
func (u UpdateWorkspaceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", u.Description)
	populate(objectMap, "displayName", u.DisplayName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateWorkspaceRequest.
func (u *UpdateWorkspaceRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &u.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &u.DisplayName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateWorkspaceRoleAssignmentRequest.
func (u UpdateWorkspaceRoleAssignmentRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "role", u.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateWorkspaceRoleAssignmentRequest.
func (u *UpdateWorkspaceRoleAssignmentRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "role":
			err = unpopulate(val, "Role", &u.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkAzureResource.
func (v VirtualNetworkAzureResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resourceGroupName", v.ResourceGroupName)
	populate(objectMap, "subnetName", v.SubnetName)
	populate(objectMap, "subscriptionId", v.SubscriptionID)
	populate(objectMap, "virtualNetworkName", v.VirtualNetworkName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkAzureResource.
func (v *VirtualNetworkAzureResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceGroupName":
			err = unpopulate(val, "ResourceGroupName", &v.ResourceGroupName)
			delete(rawMsg, key)
		case "subnetName":
			err = unpopulate(val, "SubnetName", &v.SubnetName)
			delete(rawMsg, key)
		case "subscriptionId":
			err = unpopulate(val, "SubscriptionID", &v.SubscriptionID)
			delete(rawMsg, key)
		case "virtualNetworkName":
			err = unpopulate(val, "VirtualNetworkName", &v.VirtualNetworkName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkGateway.
func (v VirtualNetworkGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityId", v.CapacityID)
	populate(objectMap, "displayName", v.DisplayName)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "inactivityMinutesBeforeSleep", v.InactivityMinutesBeforeSleep)
	populate(objectMap, "numberOfMemberGateways", v.NumberOfMemberGateways)
	objectMap["type"] = GatewayTypeVirtualNetwork
	populate(objectMap, "virtualNetworkAzureResource", v.VirtualNetworkAzureResource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkGateway.
func (v *VirtualNetworkGateway) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityId":
			err = unpopulate(val, "CapacityID", &v.CapacityID)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &v.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "inactivityMinutesBeforeSleep":
			err = unpopulate(val, "InactivityMinutesBeforeSleep", &v.InactivityMinutesBeforeSleep)
			delete(rawMsg, key)
		case "numberOfMemberGateways":
			err = unpopulate(val, "NumberOfMemberGateways", &v.NumberOfMemberGateways)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "virtualNetworkAzureResource":
			err = unpopulate(val, "VirtualNetworkAzureResource", &v.VirtualNetworkAzureResource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WeeklyScheduleConfig.
func (w WeeklyScheduleConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endDateTime", w.EndDateTime)
	populate(objectMap, "localTimeZoneId", w.LocalTimeZoneID)
	populateDateTimeRFC3339(objectMap, "startDateTime", w.StartDateTime)
	populate(objectMap, "times", w.Times)
	objectMap["type"] = ScheduleTypeWeekly
	populate(objectMap, "weekdays", w.Weekdays)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WeeklyScheduleConfig.
func (w *WeeklyScheduleConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDateTime":
			err = unpopulateDateTimeRFC3339(val, "EndDateTime", &w.EndDateTime)
			delete(rawMsg, key)
		case "localTimeZoneId":
			err = unpopulate(val, "LocalTimeZoneID", &w.LocalTimeZoneID)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateDateTimeRFC3339(val, "StartDateTime", &w.StartDateTime)
			delete(rawMsg, key)
		case "times":
			err = unpopulate(val, "Times", &w.Times)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		case "weekdays":
			err = unpopulate(val, "Weekdays", &w.Weekdays)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WindowsCredentials.
func (w WindowsCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = CredentialTypeWindows
	populate(objectMap, "password", w.Password)
	populate(objectMap, "username", w.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WindowsCredentials.
func (w *WindowsCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &w.CredentialType)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, "Password", &w.Password)
			delete(rawMsg, key)
		case "username":
			err = unpopulate(val, "Username", &w.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WindowsWithoutImpersonationCredentials.
func (w WindowsWithoutImpersonationCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = CredentialTypeWindowsWithoutImpersonation
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WindowsWithoutImpersonationCredentials.
func (w *WindowsWithoutImpersonationCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &w.CredentialType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityId", w.CapacityID)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "type", w.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Workspace.
func (w *Workspace) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityId":
			err = unpopulate(val, "CapacityID", &w.CapacityID)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceConflictResolution.
func (w WorkspaceConflictResolution) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "conflictResolutionPolicy", w.ConflictResolutionPolicy)
	populate(objectMap, "conflictResolutionType", w.ConflictResolutionType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceConflictResolution.
func (w *WorkspaceConflictResolution) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "conflictResolutionPolicy":
			err = unpopulate(val, "ConflictResolutionPolicy", &w.ConflictResolutionPolicy)
			delete(rawMsg, key)
		case "conflictResolutionType":
			err = unpopulate(val, "ConflictResolutionType", &w.ConflictResolutionType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceIdentity.
func (w WorkspaceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationId", w.ApplicationID)
	populate(objectMap, "servicePrincipalId", w.ServicePrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceIdentity.
func (w *WorkspaceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationId":
			err = unpopulate(val, "ApplicationID", &w.ApplicationID)
			delete(rawMsg, key)
		case "servicePrincipalId":
			err = unpopulate(val, "ServicePrincipalID", &w.ServicePrincipalID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceIdentityCredentials.
func (w WorkspaceIdentityCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["credentialType"] = CredentialTypeWorkspaceIdentity
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceIdentityCredentials.
func (w *WorkspaceIdentityCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credentialType":
			err = unpopulate(val, "CredentialType", &w.CredentialType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceInfo.
func (w WorkspaceInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityAssignmentProgress", w.CapacityAssignmentProgress)
	populate(objectMap, "capacityId", w.CapacityID)
	populate(objectMap, "capacityRegion", w.CapacityRegion)
	populate(objectMap, "description", w.Description)
	populate(objectMap, "displayName", w.DisplayName)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "oneLakeEndpoints", w.OneLakeEndpoints)
	populate(objectMap, "type", w.Type)
	populate(objectMap, "workspaceIdentity", w.WorkspaceIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceInfo.
func (w *WorkspaceInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityAssignmentProgress":
			err = unpopulate(val, "CapacityAssignmentProgress", &w.CapacityAssignmentProgress)
			delete(rawMsg, key)
		case "capacityId":
			err = unpopulate(val, "CapacityID", &w.CapacityID)
			delete(rawMsg, key)
		case "capacityRegion":
			err = unpopulate(val, "CapacityRegion", &w.CapacityRegion)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, "Description", &w.Description)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, "DisplayName", &w.DisplayName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "oneLakeEndpoints":
			err = unpopulate(val, "OneLakeEndpoints", &w.OneLakeEndpoints)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &w.Type)
			delete(rawMsg, key)
		case "workspaceIdentity":
			err = unpopulate(val, "WorkspaceIdentity", &w.WorkspaceIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceRoleAssignment.
func (w WorkspaceRoleAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", w.ID)
	populate(objectMap, "principal", w.Principal)
	populate(objectMap, "role", w.Role)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceRoleAssignment.
func (w *WorkspaceRoleAssignment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &w.ID)
			delete(rawMsg, key)
		case "principal":
			err = unpopulate(val, "Principal", &w.Principal)
			delete(rawMsg, key)
		case "role":
			err = unpopulate(val, "Role", &w.Role)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceRoleAssignments.
func (w WorkspaceRoleAssignments) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", w.ContinuationToken)
	populate(objectMap, "continuationUri", w.ContinuationURI)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceRoleAssignments.
func (w *WorkspaceRoleAssignments) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &w.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &w.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Workspaces.
func (w Workspaces) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "continuationToken", w.ContinuationToken)
	populate(objectMap, "continuationUri", w.ContinuationURI)
	populate(objectMap, "value", w.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Workspaces.
func (w *Workspaces) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			err = unpopulate(val, "ContinuationToken", &w.ContinuationToken)
			delete(rawMsg, key)
		case "continuationUri":
			err = unpopulate(val, "ContinuationURI", &w.ContinuationURI)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &w.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
