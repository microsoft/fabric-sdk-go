// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// SPDX-License-Identifier: MIT

package eventstream

import "encoding/json"

func unmarshalDestinationResponseClassification(rawMsg json.RawMessage) (DestinationResponseClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b DestinationResponseClassification
	switch m["type"] {
	case string(DestinationTypeActivator):
		b = &ActivatorDestinationResponse{}
	case string(DestinationTypeCustomEndpoint):
		b = &CustomEndpointDestinationResponse{}
	case string(DestinationTypeEventhouse):
		b = &EventhouseDestinationResponse{}
	case string(DestinationTypeLakehouse):
		b = &LakehouseDestinationResponse{}
	default:
		b = &DestinationResponse{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalDestinationResponseClassificationArray(rawMsg json.RawMessage) ([]DestinationResponseClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DestinationResponseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDestinationResponseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalEventhouseDestinationPropertiesClassification(rawMsg json.RawMessage) (EventhouseDestinationPropertiesClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b EventhouseDestinationPropertiesClassification
	switch m["dataIngestionMode"] {
	case string(EventhouseDestinationPropertiesDataIngestionModeDirectIngestion):
		b = &EventhouseDirectIngestionModeDestinationProperties{}
	case string(EventhouseDestinationPropertiesDataIngestionModeProcessedIngestion):
		b = &EventhouseProcessedIngestionModeDestinationProperties{}
	default:
		b = &EventhouseDestinationProperties{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalGroupByWindowClassification(rawMsg json.RawMessage) (GroupByWindowClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b GroupByWindowClassification
	switch m["type"] {
	case string(GroupByWindowTypeHopping):
		b = &HoppingWindow{}
	case string(GroupByWindowTypeSession):
		b = &SessionWindow{}
	case string(GroupByWindowTypeSliding):
		b = &SlidingWindow{}
	case string(GroupByWindowTypeSnapshot):
		b = &SnapshotWindow{}
	case string(GroupByWindowTypeTumbling):
		b = &TumblingWindow{}
	default:
		b = &GroupByWindow{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalManageFieldsOperationClassification(rawMsg json.RawMessage) (ManageFieldsOperationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b ManageFieldsOperationClassification
	switch m["type"] {
	case string(TypeCast):
		b = &ManageFieldsCastOperation{}
	case string(TypeFunctionCall):
		b = &ManageFieldsFunctionCallOperation{}
	case string(TypeRename):
		b = &ManageFieldsRenameOperation{}
	default:
		b = &ManageFieldsOperation{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalManageFieldsOperationClassificationArray(rawMsg json.RawMessage) ([]ManageFieldsOperationClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ManageFieldsOperationClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalManageFieldsOperationClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalOperatorClassification(rawMsg json.RawMessage) (OperatorClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b OperatorClassification
	switch m["type"] {
	case string(OperatorTypeAggregate):
		b = &AggregateOperator{}
	case string(OperatorTypeExpand):
		b = &ExpandOperator{}
	case string(OperatorTypeFilter):
		b = &FilterOperator{}
	case string(OperatorTypeGroupBy):
		b = &GroupByOperator{}
	case string(OperatorTypeJoin):
		b = &JoinOperator{}
	case string(OperatorTypeManageFields):
		b = &ManageFieldsOperator{}
	case string(OperatorTypeUnion):
		b = &UnionOperator{}
	default:
		b = &Operator{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalOperatorClassificationArray(rawMsg json.RawMessage) ([]OperatorClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]OperatorClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalOperatorClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalSerializationInfoClassification(rawMsg json.RawMessage) (SerializationInfoClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b SerializationInfoClassification
	switch m["type"] {
	case string(SerializationTypeAvro):
		b = &AvroSerializationInfo{}
	case string(SerializationTypeCSV):
		b = &CSVSerializationInfo{}
	case string(SerializationTypeJSON):
		b = &JSONSerializationInfo{}
	default:
		b = &SerializationInfo{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalSourceResponseClassification(rawMsg json.RawMessage) (SourceResponseClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b SourceResponseClassification
	switch m["type"] {
	case string(SourceTypeAmazonKinesis):
		b = &AmazonKinesisSourceResponse{}
	case string(SourceTypeAmazonMSKKafka):
		b = &AmazonMSKKafkaSourceResponse{}
	case string(SourceTypeApacheKafka):
		b = &ApacheKafkaSourceResponse{}
	case string(SourceTypeAzureBlobStorageEvents):
		b = &AzureBlobStorageEventsSourceResponse{}
	case string(SourceTypeAzureCosmosDBCDC):
		b = &AzureCosmosDBCDCSourceResponse{}
	case string(SourceTypeAzureEventHub):
		b = &AzureEventHubSourceResponse{}
	case string(SourceTypeAzureIoTHub):
		b = &AzureIoTHubSourceResponse{}
	case string(SourceTypeAzureSQLDBCDC):
		b = &AzureSQLDBCDCSourceResponse{}
	case string(SourceTypeAzureSQLMIDBCDC):
		b = &AzureSQLMIDBCDCSourceResponse{}
	case string(SourceTypeConfluentCloud):
		b = &ConfluentCloudSourceResponse{}
	case string(SourceTypeCustomEndpoint):
		b = &CustomEndpointSourceResponse{}
	case string(SourceTypeFabricCapacityUtilizationEvents):
		b = &FabricCapacityUtilizationEventsSourceResponse{}
	case string(SourceTypeFabricJobEvents):
		b = &FabricJobEventsSourceResponse{}
	case string(SourceTypeFabricOneLakeEvents):
		b = &FabricOneLakeEventsSourceResponse{}
	case string(SourceTypeFabricWorkspaceItemEvents):
		b = &FabricWorkspaceItemEventsSourceResponse{}
	case string(SourceTypeGooglePubSub):
		b = &GooglePubSubSourceResponse{}
	case string(SourceTypeMySQLCDC):
		b = &MySQLCDCSourceResponse{}
	case string(SourceTypePostgreSQLCDC):
		b = &PostgreSQLCDCSourceResponse{}
	case string(SourceTypeSQLServerOnVMDBCDC):
		b = &SQLServerOnVMDBCDCSourceResponse{}
	case string(SourceTypeSampleData):
		b = &SampleDataSourceResponse{}
	default:
		b = &SourceResponse{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalSourceResponseClassificationArray(rawMsg json.RawMessage) ([]SourceResponseClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SourceResponseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSourceResponseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

func unmarshalStreamResponseClassification(rawMsg json.RawMessage) (StreamResponseClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var m map[string]any
	if err := json.Unmarshal(rawMsg, &m); err != nil {
		return nil, err
	}
	var b StreamResponseClassification
	switch m["type"] {
	case string(StreamTypeDefaultStream):
		b = &DefaultStreamResponse{}
	case string(StreamTypeDerivedStream):
		b = &DerivedStreamResponse{}
	default:
		b = &StreamResponse{}
	}
	if err := json.Unmarshal(rawMsg, b); err != nil {
		return nil, err
	}
	return b, nil
}

func unmarshalStreamResponseClassificationArray(rawMsg json.RawMessage) ([]StreamResponseClassification, error) {
	if rawMsg == nil || string(rawMsg) == "null" {
		return nil, nil
	}
	var rawMessages []json.RawMessage
	if err := json.Unmarshal(rawMsg, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]StreamResponseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalStreamResponseClassification(rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}
