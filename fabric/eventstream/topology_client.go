// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// SPDX-License-Identifier: MIT

package eventstream

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"

	"github.com/microsoft/fabric-sdk-go/fabric/core"
)

// TopologyClient contains the methods for the Topology group.
// Don't use this type directly, use a constructor function instead.
type TopologyClient struct {
	internal *azcore.Client
	endpoint string
}

// GetEventstreamDestination - PERMISSIONS The caller must have viewer or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.Read.All or Eventstream.ReadWrite.All or Item.Read.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - destinationID - The destination ID.
//   - options - TopologyClientGetEventstreamDestinationOptions contains the optional parameters for the TopologyClient.GetEventstreamDestination
//     method.
func (client *TopologyClient) GetEventstreamDestination(ctx context.Context, workspaceID string, eventstreamID string, destinationID string, options *TopologyClientGetEventstreamDestinationOptions) (TopologyClientGetEventstreamDestinationResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.GetEventstreamDestination"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEventstreamDestinationCreateRequest(ctx, workspaceID, eventstreamID, destinationID, options)
	if err != nil {
		return TopologyClientGetEventstreamDestinationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientGetEventstreamDestinationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientGetEventstreamDestinationResponse{}, err
	}
	resp, err := client.getEventstreamDestinationHandleResponse(httpResp)
	return resp, err
}

// getEventstreamDestinationCreateRequest creates the GetEventstreamDestination request.
func (client *TopologyClient) getEventstreamDestinationCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, destinationID string, _ *TopologyClientGetEventstreamDestinationOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/destinations/{destinationId}"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	if destinationID == "" {
		return nil, errors.New("parameter destinationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{destinationId}", url.PathEscape(destinationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getEventstreamDestinationHandleResponse handles the GetEventstreamDestination response.
func (client *TopologyClient) getEventstreamDestinationHandleResponse(resp *http.Response) (TopologyClientGetEventstreamDestinationResponse, error) {
	result := TopologyClientGetEventstreamDestinationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result); err != nil {
		return TopologyClientGetEventstreamDestinationResponse{}, err
	}
	return result, nil
}

// GetEventstreamDestinationConnection - PERMISSIONS The caller must have contributor or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.ReadWrite.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - destinationID - The destination ID.
//   - options - TopologyClientGetEventstreamDestinationConnectionOptions contains the optional parameters for the TopologyClient.GetEventstreamDestinationConnection
//     method.
func (client *TopologyClient) GetEventstreamDestinationConnection(ctx context.Context, workspaceID string, eventstreamID string, destinationID string, options *TopologyClientGetEventstreamDestinationConnectionOptions) (TopologyClientGetEventstreamDestinationConnectionResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.GetEventstreamDestinationConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEventstreamDestinationConnectionCreateRequest(ctx, workspaceID, eventstreamID, destinationID, options)
	if err != nil {
		return TopologyClientGetEventstreamDestinationConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientGetEventstreamDestinationConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientGetEventstreamDestinationConnectionResponse{}, err
	}
	resp, err := client.getEventstreamDestinationConnectionHandleResponse(httpResp)
	return resp, err
}

// getEventstreamDestinationConnectionCreateRequest creates the GetEventstreamDestinationConnection request.
func (client *TopologyClient) getEventstreamDestinationConnectionCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, destinationID string, _ *TopologyClientGetEventstreamDestinationConnectionOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/destinations/{destinationId}/connection"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	if destinationID == "" {
		return nil, errors.New("parameter destinationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{destinationId}", url.PathEscape(destinationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getEventstreamDestinationConnectionHandleResponse handles the GetEventstreamDestinationConnection response.
func (client *TopologyClient) getEventstreamDestinationConnectionHandleResponse(resp *http.Response) (TopologyClientGetEventstreamDestinationConnectionResponse, error) {
	result := TopologyClientGetEventstreamDestinationConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DestinationConnectionResponse); err != nil {
		return TopologyClientGetEventstreamDestinationConnectionResponse{}, err
	}
	return result, nil
}

// GetEventstreamSource - PERMISSIONS The caller must have viewer or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.Read.All or Eventstream.ReadWrite.All or Item.Read.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - sourceID - The source ID.
//   - options - TopologyClientGetEventstreamSourceOptions contains the optional parameters for the TopologyClient.GetEventstreamSource
//     method.
func (client *TopologyClient) GetEventstreamSource(ctx context.Context, workspaceID string, eventstreamID string, sourceID string, options *TopologyClientGetEventstreamSourceOptions) (TopologyClientGetEventstreamSourceResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.GetEventstreamSource"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEventstreamSourceCreateRequest(ctx, workspaceID, eventstreamID, sourceID, options)
	if err != nil {
		return TopologyClientGetEventstreamSourceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientGetEventstreamSourceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientGetEventstreamSourceResponse{}, err
	}
	resp, err := client.getEventstreamSourceHandleResponse(httpResp)
	return resp, err
}

// getEventstreamSourceCreateRequest creates the GetEventstreamSource request.
func (client *TopologyClient) getEventstreamSourceCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, sourceID string, _ *TopologyClientGetEventstreamSourceOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/sources/{sourceId}"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	if sourceID == "" {
		return nil, errors.New("parameter sourceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceId}", url.PathEscape(sourceID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getEventstreamSourceHandleResponse handles the GetEventstreamSource response.
func (client *TopologyClient) getEventstreamSourceHandleResponse(resp *http.Response) (TopologyClientGetEventstreamSourceResponse, error) {
	result := TopologyClientGetEventstreamSourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result); err != nil {
		return TopologyClientGetEventstreamSourceResponse{}, err
	}
	return result, nil
}

// GetEventstreamSourceConnection - PERMISSIONS The caller must have contributor or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.ReadWrite.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - sourceID - The source ID.
//   - options - TopologyClientGetEventstreamSourceConnectionOptions contains the optional parameters for the TopologyClient.GetEventstreamSourceConnection
//     method.
func (client *TopologyClient) GetEventstreamSourceConnection(ctx context.Context, workspaceID string, eventstreamID string, sourceID string, options *TopologyClientGetEventstreamSourceConnectionOptions) (TopologyClientGetEventstreamSourceConnectionResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.GetEventstreamSourceConnection"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEventstreamSourceConnectionCreateRequest(ctx, workspaceID, eventstreamID, sourceID, options)
	if err != nil {
		return TopologyClientGetEventstreamSourceConnectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientGetEventstreamSourceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientGetEventstreamSourceConnectionResponse{}, err
	}
	resp, err := client.getEventstreamSourceConnectionHandleResponse(httpResp)
	return resp, err
}

// getEventstreamSourceConnectionCreateRequest creates the GetEventstreamSourceConnection request.
func (client *TopologyClient) getEventstreamSourceConnectionCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, sourceID string, _ *TopologyClientGetEventstreamSourceConnectionOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/sources/{sourceId}/connection"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	if sourceID == "" {
		return nil, errors.New("parameter sourceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceId}", url.PathEscape(sourceID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getEventstreamSourceConnectionHandleResponse handles the GetEventstreamSourceConnection response.
func (client *TopologyClient) getEventstreamSourceConnectionHandleResponse(resp *http.Response) (TopologyClientGetEventstreamSourceConnectionResponse, error) {
	result := TopologyClientGetEventstreamSourceConnectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SourceConnectionResponse); err != nil {
		return TopologyClientGetEventstreamSourceConnectionResponse{}, err
	}
	return result, nil
}

// GetEventstreamTopology - PERMISSIONS The caller must have viewer or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.Read.All or Eventstream.ReadWrite.All or Item.Read.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - options - TopologyClientGetEventstreamTopologyOptions contains the optional parameters for the TopologyClient.GetEventstreamTopology
//     method.
func (client *TopologyClient) GetEventstreamTopology(ctx context.Context, workspaceID string, eventstreamID string, options *TopologyClientGetEventstreamTopologyOptions) (TopologyClientGetEventstreamTopologyResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.GetEventstreamTopology"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEventstreamTopologyCreateRequest(ctx, workspaceID, eventstreamID, options)
	if err != nil {
		return TopologyClientGetEventstreamTopologyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientGetEventstreamTopologyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientGetEventstreamTopologyResponse{}, err
	}
	resp, err := client.getEventstreamTopologyHandleResponse(httpResp)
	return resp, err
}

// getEventstreamTopologyCreateRequest creates the GetEventstreamTopology request.
func (client *TopologyClient) getEventstreamTopologyCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, _ *TopologyClientGetEventstreamTopologyOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/topology"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getEventstreamTopologyHandleResponse handles the GetEventstreamTopology response.
func (client *TopologyClient) getEventstreamTopologyHandleResponse(resp *http.Response) (TopologyClientGetEventstreamTopologyResponse, error) {
	result := TopologyClientGetEventstreamTopologyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TopologyResponse); err != nil {
		return TopologyClientGetEventstreamTopologyResponse{}, err
	}
	return result, nil
}

// PauseEventstream - PERMISSIONS The caller must have contributor or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.ReadWrite.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - options - TopologyClientPauseEventstreamOptions contains the optional parameters for the TopologyClient.PauseEventstream
//     method.
func (client *TopologyClient) PauseEventstream(ctx context.Context, workspaceID string, eventstreamID string, options *TopologyClientPauseEventstreamOptions) (TopologyClientPauseEventstreamResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.PauseEventstream"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.pauseEventstreamCreateRequest(ctx, workspaceID, eventstreamID, options)
	if err != nil {
		return TopologyClientPauseEventstreamResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientPauseEventstreamResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientPauseEventstreamResponse{}, err
	}
	return TopologyClientPauseEventstreamResponse{}, nil
}

// pauseEventstreamCreateRequest creates the PauseEventstream request.
func (client *TopologyClient) pauseEventstreamCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, _ *TopologyClientPauseEventstreamOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/pause"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// PauseEventstreamDestination - PERMISSIONS The caller must have contributor or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.ReadWrite.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - destinationID - The eventstream destination ID.
//   - options - TopologyClientPauseEventstreamDestinationOptions contains the optional parameters for the TopologyClient.PauseEventstreamDestination
//     method.
func (client *TopologyClient) PauseEventstreamDestination(ctx context.Context, workspaceID string, eventstreamID string, destinationID string, options *TopologyClientPauseEventstreamDestinationOptions) (TopologyClientPauseEventstreamDestinationResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.PauseEventstreamDestination"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.pauseEventstreamDestinationCreateRequest(ctx, workspaceID, eventstreamID, destinationID, options)
	if err != nil {
		return TopologyClientPauseEventstreamDestinationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientPauseEventstreamDestinationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientPauseEventstreamDestinationResponse{}, err
	}
	return TopologyClientPauseEventstreamDestinationResponse{}, nil
}

// pauseEventstreamDestinationCreateRequest creates the PauseEventstreamDestination request.
func (client *TopologyClient) pauseEventstreamDestinationCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, destinationID string, _ *TopologyClientPauseEventstreamDestinationOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/destinations/{destinationId}/pause"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	if destinationID == "" {
		return nil, errors.New("parameter destinationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{destinationId}", url.PathEscape(destinationID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// PauseEventstreamSource - PERMISSIONS The caller must have contributor or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.ReadWrite.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - sourceID - The eventstream source ID.
//   - options - TopologyClientPauseEventstreamSourceOptions contains the optional parameters for the TopologyClient.PauseEventstreamSource
//     method.
func (client *TopologyClient) PauseEventstreamSource(ctx context.Context, workspaceID string, eventstreamID string, sourceID string, options *TopologyClientPauseEventstreamSourceOptions) (TopologyClientPauseEventstreamSourceResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.PauseEventstreamSource"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.pauseEventstreamSourceCreateRequest(ctx, workspaceID, eventstreamID, sourceID, options)
	if err != nil {
		return TopologyClientPauseEventstreamSourceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientPauseEventstreamSourceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientPauseEventstreamSourceResponse{}, err
	}
	return TopologyClientPauseEventstreamSourceResponse{}, nil
}

// pauseEventstreamSourceCreateRequest creates the PauseEventstreamSource request.
func (client *TopologyClient) pauseEventstreamSourceCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, sourceID string, _ *TopologyClientPauseEventstreamSourceOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/sources/{sourceId}/pause"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	if sourceID == "" {
		return nil, errors.New("parameter sourceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceId}", url.PathEscape(sourceID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ResumeEventstream - PERMISSIONS The caller must have contributor or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.ReadWrite.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - resumeEventstreamRequest - Resume running eventstream request payload.
//   - options - TopologyClientResumeEventstreamOptions contains the optional parameters for the TopologyClient.ResumeEventstream
//     method.
func (client *TopologyClient) ResumeEventstream(ctx context.Context, workspaceID string, eventstreamID string, resumeEventstreamRequest DataSourceStartRequest, options *TopologyClientResumeEventstreamOptions) (TopologyClientResumeEventstreamResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.ResumeEventstream"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.resumeEventstreamCreateRequest(ctx, workspaceID, eventstreamID, resumeEventstreamRequest, options)
	if err != nil {
		return TopologyClientResumeEventstreamResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientResumeEventstreamResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientResumeEventstreamResponse{}, err
	}
	return TopologyClientResumeEventstreamResponse{}, nil
}

// resumeEventstreamCreateRequest creates the ResumeEventstream request.
func (client *TopologyClient) resumeEventstreamCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, resumeEventstreamRequest DataSourceStartRequest, _ *TopologyClientResumeEventstreamOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/resume"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, resumeEventstreamRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// ResumeEventstreamDestination - PERMISSIONS The caller must have contributor or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.ReadWrite.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - destinationID - The eventstream destination ID.
//   - resumeEventstreamDestinationRequest - Resume running eventstream destination request payload.
//   - options - TopologyClientResumeEventstreamDestinationOptions contains the optional parameters for the TopologyClient.ResumeEventstreamDestination
//     method.
func (client *TopologyClient) ResumeEventstreamDestination(ctx context.Context, workspaceID string, eventstreamID string, destinationID string, resumeEventstreamDestinationRequest DataSourceStartRequest, options *TopologyClientResumeEventstreamDestinationOptions) (TopologyClientResumeEventstreamDestinationResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.ResumeEventstreamDestination"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.resumeEventstreamDestinationCreateRequest(ctx, workspaceID, eventstreamID, destinationID, resumeEventstreamDestinationRequest, options)
	if err != nil {
		return TopologyClientResumeEventstreamDestinationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientResumeEventstreamDestinationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientResumeEventstreamDestinationResponse{}, err
	}
	return TopologyClientResumeEventstreamDestinationResponse{}, nil
}

// resumeEventstreamDestinationCreateRequest creates the ResumeEventstreamDestination request.
func (client *TopologyClient) resumeEventstreamDestinationCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, destinationID string, resumeEventstreamDestinationRequest DataSourceStartRequest, _ *TopologyClientResumeEventstreamDestinationOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/destinations/{destinationId}/resume"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	if destinationID == "" {
		return nil, errors.New("parameter destinationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{destinationId}", url.PathEscape(destinationID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, resumeEventstreamDestinationRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// ResumeEventstreamSource - PERMISSIONS The caller must have contributor or higher workspace role.
// REQUIRED DELEGATED SCOPES Eventstream.ReadWrite.All or Item.ReadWrite.All
// MICROSOFT ENTRA SUPPORTED IDENTITIES This API supports the Microsoft identities [/rest/api/fabric/articles/identity-support]
// listed in this section.
// | Identity | Support | |-|-| | User | Yes | | Service principal [/entra/identity-platform/app-objects-and-service-principals#service-principal-object]
// and Managed identities
// [/entra/identity/managed-identities-azure-resources/overview] | Yes |
// INTERFACE
// If the operation fails it returns an *core.ResponseError type.
//
// Generated from API version v1
//   - workspaceID - The workspace ID.
//   - eventstreamID - The eventstream ID.
//   - sourceID - The eventstream source ID.
//   - resumeEventstreamSourceRequest - Resume running eventstream source request payload.
//   - options - TopologyClientResumeEventstreamSourceOptions contains the optional parameters for the TopologyClient.ResumeEventstreamSource
//     method.
func (client *TopologyClient) ResumeEventstreamSource(ctx context.Context, workspaceID string, eventstreamID string, sourceID string, resumeEventstreamSourceRequest DataSourceStartRequest, options *TopologyClientResumeEventstreamSourceOptions) (TopologyClientResumeEventstreamSourceResponse, error) {
	var err error
	const operationName = "eventstream.TopologyClient.ResumeEventstreamSource"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.resumeEventstreamSourceCreateRequest(ctx, workspaceID, eventstreamID, sourceID, resumeEventstreamSourceRequest, options)
	if err != nil {
		return TopologyClientResumeEventstreamSourceResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TopologyClientResumeEventstreamSourceResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = core.NewResponseError(httpResp)
		return TopologyClientResumeEventstreamSourceResponse{}, err
	}
	return TopologyClientResumeEventstreamSourceResponse{}, nil
}

// resumeEventstreamSourceCreateRequest creates the ResumeEventstreamSource request.
func (client *TopologyClient) resumeEventstreamSourceCreateRequest(ctx context.Context, workspaceID string, eventstreamID string, sourceID string, resumeEventstreamSourceRequest DataSourceStartRequest, _ *TopologyClientResumeEventstreamSourceOptions) (*policy.Request, error) {
	urlPath := "/v1/workspaces/{workspaceId}/eventstreams/{eventstreamId}/sources/{sourceId}/resume"
	if workspaceID == "" {
		return nil, errors.New("parameter workspaceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workspaceId}", url.PathEscape(workspaceID))
	if eventstreamID == "" {
		return nil, errors.New("parameter eventstreamID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{eventstreamId}", url.PathEscape(eventstreamID))
	if sourceID == "" {
		return nil, errors.New("parameter sourceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceId}", url.PathEscape(sourceID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, resumeEventstreamSourceRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// Custom code starts below
