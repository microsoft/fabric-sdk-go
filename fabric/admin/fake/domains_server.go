// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// SPDX-License-Identifier: MIT

package fake

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"

	"github.com/microsoft/fabric-sdk-go/fabric/admin"
)

// DomainsServer is a fake server for instances of the admin.DomainsClient type.
type DomainsServer struct {
	// BeginAssignDomainWorkspacesByCapacities is the fake for method DomainsClient.BeginAssignDomainWorkspacesByCapacities
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginAssignDomainWorkspacesByCapacities func(ctx context.Context, domainID string, assignDomainWorkspacesByCapacitiesRequest admin.AssignDomainWorkspacesByCapacitiesRequest, options *admin.DomainsClientBeginAssignDomainWorkspacesByCapacitiesOptions) (resp azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByCapacitiesResponse], errResp azfake.ErrorResponder)

	// AssignDomainWorkspacesByIDs is the fake for method DomainsClient.AssignDomainWorkspacesByIDs
	// HTTP status codes to indicate success: http.StatusOK
	AssignDomainWorkspacesByIDs func(ctx context.Context, domainID string, assignDomainWorkspacesByIDsRequest admin.AssignDomainWorkspacesByIDsRequest, options *admin.DomainsClientAssignDomainWorkspacesByIDsOptions) (resp azfake.Responder[admin.DomainsClientAssignDomainWorkspacesByIDsResponse], errResp azfake.ErrorResponder)

	// BeginAssignDomainWorkspacesByPrincipals is the fake for method DomainsClient.BeginAssignDomainWorkspacesByPrincipals
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginAssignDomainWorkspacesByPrincipals func(ctx context.Context, domainID string, assignDomainWorkspacesByPrincipalsRequest admin.AssignDomainWorkspacesByPrincipalsRequest, options *admin.DomainsClientBeginAssignDomainWorkspacesByPrincipalsOptions) (resp azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByPrincipalsResponse], errResp azfake.ErrorResponder)

	// CreateDomain is the fake for method DomainsClient.CreateDomain
	// HTTP status codes to indicate success: http.StatusCreated
	CreateDomain func(ctx context.Context, preview bool, createDomainRequest admin.CreateDomainRequest, options *admin.DomainsClientCreateDomainOptions) (resp azfake.Responder[admin.DomainsClientCreateDomainResponse], errResp azfake.ErrorResponder)

	// CreateDomainPreview is the fake for method DomainsClient.CreateDomainPreview
	// HTTP status codes to indicate success: http.StatusCreated
	CreateDomainPreview func(ctx context.Context, preview bool, createDomainRequest admin.CreateDomainRequest, options *admin.DomainsClientCreateDomainPreviewOptions) (resp azfake.Responder[admin.DomainsClientCreateDomainPreviewResponse], errResp azfake.ErrorResponder)

	// DeleteDomain is the fake for method DomainsClient.DeleteDomain
	// HTTP status codes to indicate success: http.StatusOK
	DeleteDomain func(ctx context.Context, domainID string, options *admin.DomainsClientDeleteDomainOptions) (resp azfake.Responder[admin.DomainsClientDeleteDomainResponse], errResp azfake.ErrorResponder)

	// GetDomain is the fake for method DomainsClient.GetDomain
	// HTTP status codes to indicate success: http.StatusOK
	GetDomain func(ctx context.Context, domainID string, preview bool, options *admin.DomainsClientGetDomainOptions) (resp azfake.Responder[admin.DomainsClientGetDomainResponse], errResp azfake.ErrorResponder)

	// GetDomainPreview is the fake for method DomainsClient.GetDomainPreview
	// HTTP status codes to indicate success: http.StatusOK
	GetDomainPreview func(ctx context.Context, domainID string, preview bool, options *admin.DomainsClientGetDomainPreviewOptions) (resp azfake.Responder[admin.DomainsClientGetDomainPreviewResponse], errResp azfake.ErrorResponder)

	// NewListDomainWorkspacesPager is the fake for method DomainsClient.NewListDomainWorkspacesPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListDomainWorkspacesPager func(domainID string, options *admin.DomainsClientListDomainWorkspacesOptions) (resp azfake.PagerResponder[admin.DomainsClientListDomainWorkspacesResponse])

	// ListDomains is the fake for method DomainsClient.ListDomains
	// HTTP status codes to indicate success: http.StatusOK
	ListDomains func(ctx context.Context, preview bool, options *admin.DomainsClientListDomainsOptions) (resp azfake.Responder[admin.DomainsClientListDomainsResponse], errResp azfake.ErrorResponder)

	// ListDomainsPreview is the fake for method DomainsClient.ListDomainsPreview
	// HTTP status codes to indicate success: http.StatusOK
	ListDomainsPreview func(ctx context.Context, preview bool, options *admin.DomainsClientListDomainsPreviewOptions) (resp azfake.Responder[admin.DomainsClientListDomainsPreviewResponse], errResp azfake.ErrorResponder)

	// NewListRoleAssignmentsPager is the fake for method DomainsClient.NewListRoleAssignmentsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListRoleAssignmentsPager func(domainID string, options *admin.DomainsClientListRoleAssignmentsOptions) (resp azfake.PagerResponder[admin.DomainsClientListRoleAssignmentsResponse])

	// RoleAssignmentsBulkAssign is the fake for method DomainsClient.RoleAssignmentsBulkAssign
	// HTTP status codes to indicate success: http.StatusOK
	RoleAssignmentsBulkAssign func(ctx context.Context, domainID string, domainRoleAssignmentRequest admin.DomainRoleAssignmentRequest, options *admin.DomainsClientRoleAssignmentsBulkAssignOptions) (resp azfake.Responder[admin.DomainsClientRoleAssignmentsBulkAssignResponse], errResp azfake.ErrorResponder)

	// RoleAssignmentsBulkUnassign is the fake for method DomainsClient.RoleAssignmentsBulkUnassign
	// HTTP status codes to indicate success: http.StatusOK
	RoleAssignmentsBulkUnassign func(ctx context.Context, domainID string, domainRoleUnassignmentRequest admin.DomainRoleUnassignmentRequest, options *admin.DomainsClientRoleAssignmentsBulkUnassignOptions) (resp azfake.Responder[admin.DomainsClientRoleAssignmentsBulkUnassignResponse], errResp azfake.ErrorResponder)

	// SyncRoleAssignmentsToSubdomains is the fake for method DomainsClient.SyncRoleAssignmentsToSubdomains
	// HTTP status codes to indicate success: http.StatusOK
	SyncRoleAssignmentsToSubdomains func(ctx context.Context, domainID string, syncRoleAssignmentsToSubdomainsRequest admin.SyncRoleAssignmentsToSubdomainsRequest, options *admin.DomainsClientSyncRoleAssignmentsToSubdomainsOptions) (resp azfake.Responder[admin.DomainsClientSyncRoleAssignmentsToSubdomainsResponse], errResp azfake.ErrorResponder)

	// UnassignAllDomainWorkspaces is the fake for method DomainsClient.UnassignAllDomainWorkspaces
	// HTTP status codes to indicate success: http.StatusOK
	UnassignAllDomainWorkspaces func(ctx context.Context, domainID string, options *admin.DomainsClientUnassignAllDomainWorkspacesOptions) (resp azfake.Responder[admin.DomainsClientUnassignAllDomainWorkspacesResponse], errResp azfake.ErrorResponder)

	// UnassignDomainWorkspacesByIDs is the fake for method DomainsClient.UnassignDomainWorkspacesByIDs
	// HTTP status codes to indicate success: http.StatusOK
	UnassignDomainWorkspacesByIDs func(ctx context.Context, domainID string, options *admin.DomainsClientUnassignDomainWorkspacesByIDsOptions) (resp azfake.Responder[admin.DomainsClientUnassignDomainWorkspacesByIDsResponse], errResp azfake.ErrorResponder)

	// UpdateDomain is the fake for method DomainsClient.UpdateDomain
	// HTTP status codes to indicate success: http.StatusOK
	UpdateDomain func(ctx context.Context, domainID string, preview bool, updateDomainRequest admin.UpdateDomainRequest, options *admin.DomainsClientUpdateDomainOptions) (resp azfake.Responder[admin.DomainsClientUpdateDomainResponse], errResp azfake.ErrorResponder)

	// UpdateDomainPreview is the fake for method DomainsClient.UpdateDomainPreview
	// HTTP status codes to indicate success: http.StatusOK
	UpdateDomainPreview func(ctx context.Context, domainID string, preview bool, updateDomainRequest admin.UpdateDomainRequestPreview, options *admin.DomainsClientUpdateDomainPreviewOptions) (resp azfake.Responder[admin.DomainsClientUpdateDomainPreviewResponse], errResp azfake.ErrorResponder)
}

// NewDomainsServerTransport creates a new instance of DomainsServerTransport with the provided implementation.
// The returned DomainsServerTransport instance is connected to an instance of admin.DomainsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewDomainsServerTransport(srv *DomainsServer) *DomainsServerTransport {
	return &DomainsServerTransport{
		srv:                                     srv,
		beginAssignDomainWorkspacesByCapacities: newTracker[azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByCapacitiesResponse]](),
		beginAssignDomainWorkspacesByPrincipals: newTracker[azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByPrincipalsResponse]](),
		newListDomainWorkspacesPager:            newTracker[azfake.PagerResponder[admin.DomainsClientListDomainWorkspacesResponse]](),
		newListRoleAssignmentsPager:             newTracker[azfake.PagerResponder[admin.DomainsClientListRoleAssignmentsResponse]](),
	}
}

// DomainsServerTransport connects instances of admin.DomainsClient to instances of DomainsServer.
// Don't use this type directly, use NewDomainsServerTransport instead.
type DomainsServerTransport struct {
	srv                                     *DomainsServer
	beginAssignDomainWorkspacesByCapacities *tracker[azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByCapacitiesResponse]]
	beginAssignDomainWorkspacesByPrincipals *tracker[azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByPrincipalsResponse]]
	newListDomainWorkspacesPager            *tracker[azfake.PagerResponder[admin.DomainsClientListDomainWorkspacesResponse]]
	newListRoleAssignmentsPager             *tracker[azfake.PagerResponder[admin.DomainsClientListRoleAssignmentsResponse]]
}

// Do implements the policy.Transporter interface for DomainsServerTransport.
func (d *DomainsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	parts := strings.Split(method, ".")
	method = parts[1] + "." + parts[2]
	return d.dispatchToMethodFake(req, method)
}

func (d *DomainsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if domainsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = domainsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "DomainsClient.BeginAssignDomainWorkspacesByCapacities":
				res.resp, res.err = d.dispatchBeginAssignDomainWorkspacesByCapacities(req)
			case "DomainsClient.AssignDomainWorkspacesByIDs":
				res.resp, res.err = d.dispatchAssignDomainWorkspacesByIDs(req)
			case "DomainsClient.BeginAssignDomainWorkspacesByPrincipals":
				res.resp, res.err = d.dispatchBeginAssignDomainWorkspacesByPrincipals(req)
			case "DomainsClient.CreateDomain":
				res.resp, res.err = d.dispatchCreateDomain(req)
			case "DomainsClient.CreateDomainPreview":
				res.resp, res.err = d.dispatchCreateDomainPreview(req)
			case "DomainsClient.DeleteDomain":
				res.resp, res.err = d.dispatchDeleteDomain(req)
			case "DomainsClient.GetDomain":
				res.resp, res.err = d.dispatchGetDomain(req)
			case "DomainsClient.GetDomainPreview":
				res.resp, res.err = d.dispatchGetDomainPreview(req)
			case "DomainsClient.NewListDomainWorkspacesPager":
				res.resp, res.err = d.dispatchNewListDomainWorkspacesPager(req)
			case "DomainsClient.ListDomains":
				res.resp, res.err = d.dispatchListDomains(req)
			case "DomainsClient.ListDomainsPreview":
				res.resp, res.err = d.dispatchListDomainsPreview(req)
			case "DomainsClient.NewListRoleAssignmentsPager":
				res.resp, res.err = d.dispatchNewListRoleAssignmentsPager(req)
			case "DomainsClient.RoleAssignmentsBulkAssign":
				res.resp, res.err = d.dispatchRoleAssignmentsBulkAssign(req)
			case "DomainsClient.RoleAssignmentsBulkUnassign":
				res.resp, res.err = d.dispatchRoleAssignmentsBulkUnassign(req)
			case "DomainsClient.SyncRoleAssignmentsToSubdomains":
				res.resp, res.err = d.dispatchSyncRoleAssignmentsToSubdomains(req)
			case "DomainsClient.UnassignAllDomainWorkspaces":
				res.resp, res.err = d.dispatchUnassignAllDomainWorkspaces(req)
			case "DomainsClient.UnassignDomainWorkspacesByIDs":
				res.resp, res.err = d.dispatchUnassignDomainWorkspacesByIDs(req)
			case "DomainsClient.UpdateDomain":
				res.resp, res.err = d.dispatchUpdateDomain(req)
			case "DomainsClient.UpdateDomainPreview":
				res.resp, res.err = d.dispatchUpdateDomainPreview(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (d *DomainsServerTransport) dispatchBeginAssignDomainWorkspacesByCapacities(req *http.Request) (*http.Response, error) {
	if d.srv.BeginAssignDomainWorkspacesByCapacities == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginAssignDomainWorkspacesByCapacities not implemented")}
	}
	beginAssignDomainWorkspacesByCapacities := d.beginAssignDomainWorkspacesByCapacities.get(req)
	if beginAssignDomainWorkspacesByCapacities == nil {
		const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/assignWorkspacesByCapacities`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[admin.AssignDomainWorkspacesByCapacitiesRequest](req)
		if err != nil {
			return nil, err
		}
		domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginAssignDomainWorkspacesByCapacities(req.Context(), domainIDParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginAssignDomainWorkspacesByCapacities = &respr
		d.beginAssignDomainWorkspacesByCapacities.add(req, beginAssignDomainWorkspacesByCapacities)
	}

	resp, err := server.PollerResponderNext(beginAssignDomainWorkspacesByCapacities, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		d.beginAssignDomainWorkspacesByCapacities.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginAssignDomainWorkspacesByCapacities) {
		d.beginAssignDomainWorkspacesByCapacities.remove(req)
	}

	return resp, nil
}

func (d *DomainsServerTransport) dispatchAssignDomainWorkspacesByIDs(req *http.Request) (*http.Response, error) {
	if d.srv.AssignDomainWorkspacesByIDs == nil {
		return nil, &nonRetriableError{errors.New("fake for method AssignDomainWorkspacesByIDs not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/assignWorkspaces`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.AssignDomainWorkspacesByIDsRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.AssignDomainWorkspacesByIDs(req.Context(), domainIDParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchBeginAssignDomainWorkspacesByPrincipals(req *http.Request) (*http.Response, error) {
	if d.srv.BeginAssignDomainWorkspacesByPrincipals == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginAssignDomainWorkspacesByPrincipals not implemented")}
	}
	beginAssignDomainWorkspacesByPrincipals := d.beginAssignDomainWorkspacesByPrincipals.get(req)
	if beginAssignDomainWorkspacesByPrincipals == nil {
		const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/assignWorkspacesByPrincipals`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[admin.AssignDomainWorkspacesByPrincipalsRequest](req)
		if err != nil {
			return nil, err
		}
		domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginAssignDomainWorkspacesByPrincipals(req.Context(), domainIDParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginAssignDomainWorkspacesByPrincipals = &respr
		d.beginAssignDomainWorkspacesByPrincipals.add(req, beginAssignDomainWorkspacesByPrincipals)
	}

	resp, err := server.PollerResponderNext(beginAssignDomainWorkspacesByPrincipals, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		d.beginAssignDomainWorkspacesByPrincipals.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginAssignDomainWorkspacesByPrincipals) {
		d.beginAssignDomainWorkspacesByPrincipals.remove(req)
	}

	return resp, nil
}

func (d *DomainsServerTransport) dispatchCreateDomain(req *http.Request) (*http.Response, error) {
	if d.srv.CreateDomain == nil {
		return nil, &nonRetriableError{errors.New("fake for method CreateDomain not implemented")}
	}
	qp := req.URL.Query()
	body, err := server.UnmarshalRequestAsJSON[admin.CreateDomainRequest](req)
	if err != nil {
		return nil, err
	}
	previewUnescaped, err := url.QueryUnescape(qp.Get("preview"))
	if err != nil {
		return nil, err
	}
	previewParam, err := strconv.ParseBool(previewUnescaped)
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.CreateDomain(req.Context(), previewParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusCreated}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Domain, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchCreateDomainPreview(req *http.Request) (*http.Response, error) {
	if d.srv.CreateDomainPreview == nil {
		return nil, &nonRetriableError{errors.New("fake for method CreateDomainPreview not implemented")}
	}
	qp := req.URL.Query()
	body, err := server.UnmarshalRequestAsJSON[admin.CreateDomainRequest](req)
	if err != nil {
		return nil, err
	}
	previewUnescaped, err := url.QueryUnescape(qp.Get("preview"))
	if err != nil {
		return nil, err
	}
	previewParam, err := strconv.ParseBool(previewUnescaped)
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.CreateDomainPreview(req.Context(), previewParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusCreated}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DomainPreview, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchDeleteDomain(req *http.Request) (*http.Response, error) {
	if d.srv.DeleteDomain == nil {
		return nil, &nonRetriableError{errors.New("fake for method DeleteDomain not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.DeleteDomain(req.Context(), domainIDParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchGetDomain(req *http.Request) (*http.Response, error) {
	if d.srv.GetDomain == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetDomain not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	previewUnescaped, err := url.QueryUnescape(qp.Get("preview"))
	if err != nil {
		return nil, err
	}
	previewParam, err := strconv.ParseBool(previewUnescaped)
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.GetDomain(req.Context(), domainIDParam, previewParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Domain, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchGetDomainPreview(req *http.Request) (*http.Response, error) {
	if d.srv.GetDomainPreview == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetDomainPreview not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	previewUnescaped, err := url.QueryUnescape(qp.Get("preview"))
	if err != nil {
		return nil, err
	}
	previewParam, err := strconv.ParseBool(previewUnescaped)
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.GetDomainPreview(req.Context(), domainIDParam, previewParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DomainPreview, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchNewListDomainWorkspacesPager(req *http.Request) (*http.Response, error) {
	if d.srv.NewListDomainWorkspacesPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListDomainWorkspacesPager not implemented")}
	}
	newListDomainWorkspacesPager := d.newListDomainWorkspacesPager.get(req)
	if newListDomainWorkspacesPager == nil {
		const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/workspaces`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
		if err != nil {
			return nil, err
		}
		continuationTokenUnescaped, err := url.QueryUnescape(qp.Get("continuationToken"))
		if err != nil {
			return nil, err
		}
		continuationTokenParam := getOptional(continuationTokenUnescaped)
		var options *admin.DomainsClientListDomainWorkspacesOptions
		if continuationTokenParam != nil {
			options = &admin.DomainsClientListDomainWorkspacesOptions{
				ContinuationToken: continuationTokenParam,
			}
		}
		resp := d.srv.NewListDomainWorkspacesPager(domainIDParam, options)
		newListDomainWorkspacesPager = &resp
		d.newListDomainWorkspacesPager.add(req, newListDomainWorkspacesPager)
		server.PagerResponderInjectNextLinks(newListDomainWorkspacesPager, req, func(page *admin.DomainsClientListDomainWorkspacesResponse, createLink func() string) {
			page.ContinuationURI = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListDomainWorkspacesPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		d.newListDomainWorkspacesPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListDomainWorkspacesPager) {
		d.newListDomainWorkspacesPager.remove(req)
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchListDomains(req *http.Request) (*http.Response, error) {
	if d.srv.ListDomains == nil {
		return nil, &nonRetriableError{errors.New("fake for method ListDomains not implemented")}
	}
	qp := req.URL.Query()
	nonEmptyOnlyUnescaped, err := url.QueryUnescape(qp.Get("nonEmptyOnly"))
	if err != nil {
		return nil, err
	}
	nonEmptyOnlyParam, err := parseOptional(nonEmptyOnlyUnescaped, strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	previewUnescaped, err := url.QueryUnescape(qp.Get("preview"))
	if err != nil {
		return nil, err
	}
	previewParam, err := strconv.ParseBool(previewUnescaped)
	if err != nil {
		return nil, err
	}
	var options *admin.DomainsClientListDomainsOptions
	if nonEmptyOnlyParam != nil {
		options = &admin.DomainsClientListDomainsOptions{
			NonEmptyOnly: nonEmptyOnlyParam,
		}
	}
	respr, errRespr := d.srv.ListDomains(req.Context(), previewParam, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DomainsResponse, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchListDomainsPreview(req *http.Request) (*http.Response, error) {
	if d.srv.ListDomainsPreview == nil {
		return nil, &nonRetriableError{errors.New("fake for method ListDomainsPreview not implemented")}
	}
	qp := req.URL.Query()
	nonEmptyOnlyUnescaped, err := url.QueryUnescape(qp.Get("nonEmptyOnly"))
	if err != nil {
		return nil, err
	}
	nonEmptyOnlyParam, err := parseOptional(nonEmptyOnlyUnescaped, strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	previewUnescaped, err := url.QueryUnescape(qp.Get("preview"))
	if err != nil {
		return nil, err
	}
	previewParam, err := strconv.ParseBool(previewUnescaped)
	if err != nil {
		return nil, err
	}
	var options *admin.DomainsClientListDomainsPreviewOptions
	if nonEmptyOnlyParam != nil {
		options = &admin.DomainsClientListDomainsPreviewOptions{
			NonEmptyOnly: nonEmptyOnlyParam,
		}
	}
	respr, errRespr := d.srv.ListDomainsPreview(req.Context(), previewParam, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DomainsResponsePreview, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchNewListRoleAssignmentsPager(req *http.Request) (*http.Response, error) {
	if d.srv.NewListRoleAssignmentsPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListRoleAssignmentsPager not implemented")}
	}
	newListRoleAssignmentsPager := d.newListRoleAssignmentsPager.get(req)
	if newListRoleAssignmentsPager == nil {
		const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/roleAssignments`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if len(matches) < 2 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
		if err != nil {
			return nil, err
		}
		continuationTokenUnescaped, err := url.QueryUnescape(qp.Get("continuationToken"))
		if err != nil {
			return nil, err
		}
		continuationTokenParam := getOptional(continuationTokenUnescaped)
		var options *admin.DomainsClientListRoleAssignmentsOptions
		if continuationTokenParam != nil {
			options = &admin.DomainsClientListRoleAssignmentsOptions{
				ContinuationToken: continuationTokenParam,
			}
		}
		resp := d.srv.NewListRoleAssignmentsPager(domainIDParam, options)
		newListRoleAssignmentsPager = &resp
		d.newListRoleAssignmentsPager.add(req, newListRoleAssignmentsPager)
		server.PagerResponderInjectNextLinks(newListRoleAssignmentsPager, req, func(page *admin.DomainsClientListRoleAssignmentsResponse, createLink func() string) {
			page.ContinuationURI = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListRoleAssignmentsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		d.newListRoleAssignmentsPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListRoleAssignmentsPager) {
		d.newListRoleAssignmentsPager.remove(req)
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchRoleAssignmentsBulkAssign(req *http.Request) (*http.Response, error) {
	if d.srv.RoleAssignmentsBulkAssign == nil {
		return nil, &nonRetriableError{errors.New("fake for method RoleAssignmentsBulkAssign not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/roleAssignments/bulkAssign`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.DomainRoleAssignmentRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.RoleAssignmentsBulkAssign(req.Context(), domainIDParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchRoleAssignmentsBulkUnassign(req *http.Request) (*http.Response, error) {
	if d.srv.RoleAssignmentsBulkUnassign == nil {
		return nil, &nonRetriableError{errors.New("fake for method RoleAssignmentsBulkUnassign not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/roleAssignments/bulkUnassign`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.DomainRoleUnassignmentRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.RoleAssignmentsBulkUnassign(req.Context(), domainIDParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchSyncRoleAssignmentsToSubdomains(req *http.Request) (*http.Response, error) {
	if d.srv.SyncRoleAssignmentsToSubdomains == nil {
		return nil, &nonRetriableError{errors.New("fake for method SyncRoleAssignmentsToSubdomains not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/roleAssignments/syncToSubdomains`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.SyncRoleAssignmentsToSubdomainsRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.SyncRoleAssignmentsToSubdomains(req.Context(), domainIDParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchUnassignAllDomainWorkspaces(req *http.Request) (*http.Response, error) {
	if d.srv.UnassignAllDomainWorkspaces == nil {
		return nil, &nonRetriableError{errors.New("fake for method UnassignAllDomainWorkspaces not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/unassignAllWorkspaces`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.UnassignAllDomainWorkspaces(req.Context(), domainIDParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchUnassignDomainWorkspacesByIDs(req *http.Request) (*http.Response, error) {
	if d.srv.UnassignDomainWorkspacesByIDs == nil {
		return nil, &nonRetriableError{errors.New("fake for method UnassignDomainWorkspacesByIDs not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/unassignWorkspaces`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.UnassignDomainWorkspacesByIDsRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	var options *admin.DomainsClientUnassignDomainWorkspacesByIDsOptions
	if !reflect.ValueOf(body).IsZero() {
		options = &admin.DomainsClientUnassignDomainWorkspacesByIDsOptions{
			UnassignDomainWorkspacesByIDsRequest: &body,
		}
	}
	respr, errRespr := d.srv.UnassignDomainWorkspacesByIDs(req.Context(), domainIDParam, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchUpdateDomain(req *http.Request) (*http.Response, error) {
	if d.srv.UpdateDomain == nil {
		return nil, &nonRetriableError{errors.New("fake for method UpdateDomain not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	body, err := server.UnmarshalRequestAsJSON[admin.UpdateDomainRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	previewUnescaped, err := url.QueryUnescape(qp.Get("preview"))
	if err != nil {
		return nil, err
	}
	previewParam, err := strconv.ParseBool(previewUnescaped)
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.UpdateDomain(req.Context(), domainIDParam, previewParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Domain, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchUpdateDomainPreview(req *http.Request) (*http.Response, error) {
	if d.srv.UpdateDomainPreview == nil {
		return nil, &nonRetriableError{errors.New("fake for method UpdateDomainPreview not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	body, err := server.UnmarshalRequestAsJSON[admin.UpdateDomainRequestPreview](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	previewUnescaped, err := url.QueryUnescape(qp.Get("preview"))
	if err != nil {
		return nil, err
	}
	previewParam, err := strconv.ParseBool(previewUnescaped)
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.UpdateDomainPreview(req.Context(), domainIDParam, previewParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DomainPreview, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to DomainsServerTransport
var domainsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}
