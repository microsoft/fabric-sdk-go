// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See LICENSE in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// SPDX-License-Identifier: MIT

package fake

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"

	"github.com/microsoft/fabric-sdk-go/fabric/admin"
)

// DomainsServer is a fake server for instances of the admin.DomainsClient type.
type DomainsServer struct {
	// BeginAssignDomainWorkspacesByCapacities is the fake for method DomainsClient.BeginAssignDomainWorkspacesByCapacities
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginAssignDomainWorkspacesByCapacities func(ctx context.Context, domainID string, assignDomainWorkspacesByCapacitiesRequest admin.AssignDomainWorkspacesByCapacitiesRequest, options *admin.DomainsClientBeginAssignDomainWorkspacesByCapacitiesOptions) (resp azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByCapacitiesResponse], errResp azfake.ErrorResponder)

	// AssignDomainWorkspacesByIDs is the fake for method DomainsClient.AssignDomainWorkspacesByIDs
	// HTTP status codes to indicate success: http.StatusOK
	AssignDomainWorkspacesByIDs func(ctx context.Context, domainID string, assignDomainWorkspacesByIDsRequest admin.AssignDomainWorkspacesByIDsRequest, options *admin.DomainsClientAssignDomainWorkspacesByIDsOptions) (resp azfake.Responder[admin.DomainsClientAssignDomainWorkspacesByIDsResponse], errResp azfake.ErrorResponder)

	// BeginAssignDomainWorkspacesByPrincipals is the fake for method DomainsClient.BeginAssignDomainWorkspacesByPrincipals
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginAssignDomainWorkspacesByPrincipals func(ctx context.Context, domainID string, assignDomainWorkspacesByPrincipalsRequest admin.AssignDomainWorkspacesByPrincipalsRequest, options *admin.DomainsClientBeginAssignDomainWorkspacesByPrincipalsOptions) (resp azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByPrincipalsResponse], errResp azfake.ErrorResponder)

	// CreateDomain is the fake for method DomainsClient.CreateDomain
	// HTTP status codes to indicate success: http.StatusCreated
	CreateDomain func(ctx context.Context, createDomainRequest admin.CreateDomainRequest, options *admin.DomainsClientCreateDomainOptions) (resp azfake.Responder[admin.DomainsClientCreateDomainResponse], errResp azfake.ErrorResponder)

	// DeleteDomain is the fake for method DomainsClient.DeleteDomain
	// HTTP status codes to indicate success: http.StatusOK
	DeleteDomain func(ctx context.Context, domainID string, options *admin.DomainsClientDeleteDomainOptions) (resp azfake.Responder[admin.DomainsClientDeleteDomainResponse], errResp azfake.ErrorResponder)

	// GetDomain is the fake for method DomainsClient.GetDomain
	// HTTP status codes to indicate success: http.StatusOK
	GetDomain func(ctx context.Context, domainID string, options *admin.DomainsClientGetDomainOptions) (resp azfake.Responder[admin.DomainsClientGetDomainResponse], errResp azfake.ErrorResponder)

	// NewListDomainWorkspacesPager is the fake for method DomainsClient.NewListDomainWorkspacesPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListDomainWorkspacesPager func(domainID string, options *admin.DomainsClientListDomainWorkspacesOptions) (resp azfake.PagerResponder[admin.DomainsClientListDomainWorkspacesResponse])

	// ListDomains is the fake for method DomainsClient.ListDomains
	// HTTP status codes to indicate success: http.StatusOK
	ListDomains func(ctx context.Context, options *admin.DomainsClientListDomainsOptions) (resp azfake.Responder[admin.DomainsClientListDomainsResponse], errResp azfake.ErrorResponder)

	// RoleAssignmentsBulkAssign is the fake for method DomainsClient.RoleAssignmentsBulkAssign
	// HTTP status codes to indicate success: http.StatusOK
	RoleAssignmentsBulkAssign func(ctx context.Context, domainID string, domainRoleAssignmentRequest admin.DomainRoleAssignmentRequest, options *admin.DomainsClientRoleAssignmentsBulkAssignOptions) (resp azfake.Responder[admin.DomainsClientRoleAssignmentsBulkAssignResponse], errResp azfake.ErrorResponder)

	// RoleAssignmentsBulkUnassign is the fake for method DomainsClient.RoleAssignmentsBulkUnassign
	// HTTP status codes to indicate success: http.StatusOK
	RoleAssignmentsBulkUnassign func(ctx context.Context, domainID string, domainRoleUnassignmentRequest admin.DomainRoleUnassignmentRequest, options *admin.DomainsClientRoleAssignmentsBulkUnassignOptions) (resp azfake.Responder[admin.DomainsClientRoleAssignmentsBulkUnassignResponse], errResp azfake.ErrorResponder)

	// UnassignAllDomainWorkspaces is the fake for method DomainsClient.UnassignAllDomainWorkspaces
	// HTTP status codes to indicate success: http.StatusOK
	UnassignAllDomainWorkspaces func(ctx context.Context, domainID string, options *admin.DomainsClientUnassignAllDomainWorkspacesOptions) (resp azfake.Responder[admin.DomainsClientUnassignAllDomainWorkspacesResponse], errResp azfake.ErrorResponder)

	// UnassignDomainWorkspacesByIDs is the fake for method DomainsClient.UnassignDomainWorkspacesByIDs
	// HTTP status codes to indicate success: http.StatusOK
	UnassignDomainWorkspacesByIDs func(ctx context.Context, domainID string, options *admin.DomainsClientUnassignDomainWorkspacesByIDsOptions) (resp azfake.Responder[admin.DomainsClientUnassignDomainWorkspacesByIDsResponse], errResp azfake.ErrorResponder)

	// UpdateDomain is the fake for method DomainsClient.UpdateDomain
	// HTTP status codes to indicate success: http.StatusOK
	UpdateDomain func(ctx context.Context, domainID string, updateDomainRequest admin.UpdateDomainRequest, options *admin.DomainsClientUpdateDomainOptions) (resp azfake.Responder[admin.DomainsClientUpdateDomainResponse], errResp azfake.ErrorResponder)
}

// NewDomainsServerTransport creates a new instance of DomainsServerTransport with the provided implementation.
// The returned DomainsServerTransport instance is connected to an instance of admin.DomainsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewDomainsServerTransport(srv *DomainsServer) *DomainsServerTransport {
	return &DomainsServerTransport{
		srv:                                     srv,
		beginAssignDomainWorkspacesByCapacities: newTracker[azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByCapacitiesResponse]](),
		beginAssignDomainWorkspacesByPrincipals: newTracker[azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByPrincipalsResponse]](),
		newListDomainWorkspacesPager:            newTracker[azfake.PagerResponder[admin.DomainsClientListDomainWorkspacesResponse]](),
	}
}

// DomainsServerTransport connects instances of admin.DomainsClient to instances of DomainsServer.
// Don't use this type directly, use NewDomainsServerTransport instead.
type DomainsServerTransport struct {
	srv                                     *DomainsServer
	beginAssignDomainWorkspacesByCapacities *tracker[azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByCapacitiesResponse]]
	beginAssignDomainWorkspacesByPrincipals *tracker[azfake.PollerResponder[admin.DomainsClientAssignDomainWorkspacesByPrincipalsResponse]]
	newListDomainWorkspacesPager            *tracker[azfake.PagerResponder[admin.DomainsClientListDomainWorkspacesResponse]]
}

// Do implements the policy.Transporter interface for DomainsServerTransport.
func (d *DomainsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	parts := strings.Split(method, ".")
	method = parts[1] + "." + parts[2]
	return d.dispatchToMethodFake(req, method)
}

func (d *DomainsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	var resp *http.Response
	var err error

	switch method {
	case "DomainsClient.BeginAssignDomainWorkspacesByCapacities":
		resp, err = d.dispatchBeginAssignDomainWorkspacesByCapacities(req)
	case "DomainsClient.AssignDomainWorkspacesByIDs":
		resp, err = d.dispatchAssignDomainWorkspacesByIDs(req)
	case "DomainsClient.BeginAssignDomainWorkspacesByPrincipals":
		resp, err = d.dispatchBeginAssignDomainWorkspacesByPrincipals(req)
	case "DomainsClient.CreateDomain":
		resp, err = d.dispatchCreateDomain(req)
	case "DomainsClient.DeleteDomain":
		resp, err = d.dispatchDeleteDomain(req)
	case "DomainsClient.GetDomain":
		resp, err = d.dispatchGetDomain(req)
	case "DomainsClient.NewListDomainWorkspacesPager":
		resp, err = d.dispatchNewListDomainWorkspacesPager(req)
	case "DomainsClient.ListDomains":
		resp, err = d.dispatchListDomains(req)
	case "DomainsClient.RoleAssignmentsBulkAssign":
		resp, err = d.dispatchRoleAssignmentsBulkAssign(req)
	case "DomainsClient.RoleAssignmentsBulkUnassign":
		resp, err = d.dispatchRoleAssignmentsBulkUnassign(req)
	case "DomainsClient.UnassignAllDomainWorkspaces":
		resp, err = d.dispatchUnassignAllDomainWorkspaces(req)
	case "DomainsClient.UnassignDomainWorkspacesByIDs":
		resp, err = d.dispatchUnassignDomainWorkspacesByIDs(req)
	case "DomainsClient.UpdateDomain":
		resp, err = d.dispatchUpdateDomain(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	return resp, err
}

func (d *DomainsServerTransport) dispatchBeginAssignDomainWorkspacesByCapacities(req *http.Request) (*http.Response, error) {
	if d.srv.BeginAssignDomainWorkspacesByCapacities == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginAssignDomainWorkspacesByCapacities not implemented")}
	}
	beginAssignDomainWorkspacesByCapacities := d.beginAssignDomainWorkspacesByCapacities.get(req)
	if beginAssignDomainWorkspacesByCapacities == nil {
		const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/assignWorkspacesByCapacities`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[admin.AssignDomainWorkspacesByCapacitiesRequest](req)
		if err != nil {
			return nil, err
		}
		domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginAssignDomainWorkspacesByCapacities(req.Context(), domainIDParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginAssignDomainWorkspacesByCapacities = &respr
		d.beginAssignDomainWorkspacesByCapacities.add(req, beginAssignDomainWorkspacesByCapacities)
	}

	resp, err := server.PollerResponderNext(beginAssignDomainWorkspacesByCapacities, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		d.beginAssignDomainWorkspacesByCapacities.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginAssignDomainWorkspacesByCapacities) {
		d.beginAssignDomainWorkspacesByCapacities.remove(req)
	}

	return resp, nil
}

func (d *DomainsServerTransport) dispatchAssignDomainWorkspacesByIDs(req *http.Request) (*http.Response, error) {
	if d.srv.AssignDomainWorkspacesByIDs == nil {
		return nil, &nonRetriableError{errors.New("fake for method AssignDomainWorkspacesByIDs not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/assignWorkspaces`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.AssignDomainWorkspacesByIDsRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.AssignDomainWorkspacesByIDs(req.Context(), domainIDParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchBeginAssignDomainWorkspacesByPrincipals(req *http.Request) (*http.Response, error) {
	if d.srv.BeginAssignDomainWorkspacesByPrincipals == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginAssignDomainWorkspacesByPrincipals not implemented")}
	}
	beginAssignDomainWorkspacesByPrincipals := d.beginAssignDomainWorkspacesByPrincipals.get(req)
	if beginAssignDomainWorkspacesByPrincipals == nil {
		const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/assignWorkspacesByPrincipals`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[admin.AssignDomainWorkspacesByPrincipalsRequest](req)
		if err != nil {
			return nil, err
		}
		domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
		if err != nil {
			return nil, err
		}
		respr, errRespr := d.srv.BeginAssignDomainWorkspacesByPrincipals(req.Context(), domainIDParam, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginAssignDomainWorkspacesByPrincipals = &respr
		d.beginAssignDomainWorkspacesByPrincipals.add(req, beginAssignDomainWorkspacesByPrincipals)
	}

	resp, err := server.PollerResponderNext(beginAssignDomainWorkspacesByPrincipals, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		d.beginAssignDomainWorkspacesByPrincipals.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginAssignDomainWorkspacesByPrincipals) {
		d.beginAssignDomainWorkspacesByPrincipals.remove(req)
	}

	return resp, nil
}

func (d *DomainsServerTransport) dispatchCreateDomain(req *http.Request) (*http.Response, error) {
	if d.srv.CreateDomain == nil {
		return nil, &nonRetriableError{errors.New("fake for method CreateDomain not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[admin.CreateDomainRequest](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.CreateDomain(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusCreated}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Domain, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchDeleteDomain(req *http.Request) (*http.Response, error) {
	if d.srv.DeleteDomain == nil {
		return nil, &nonRetriableError{errors.New("fake for method DeleteDomain not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.DeleteDomain(req.Context(), domainIDParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchGetDomain(req *http.Request) (*http.Response, error) {
	if d.srv.GetDomain == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetDomain not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.GetDomain(req.Context(), domainIDParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Domain, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchNewListDomainWorkspacesPager(req *http.Request) (*http.Response, error) {
	if d.srv.NewListDomainWorkspacesPager == nil {
		return nil, &nonRetriableError{errors.New("fake for method NewListDomainWorkspacesPager not implemented")}
	}
	newListDomainWorkspacesPager := d.newListDomainWorkspacesPager.get(req)
	if newListDomainWorkspacesPager == nil {
		const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/workspaces`
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.EscapedPath())
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
		if err != nil {
			return nil, err
		}
		continuationTokenUnescaped, err := url.QueryUnescape(qp.Get("continuationToken"))
		if err != nil {
			return nil, err
		}
		continuationTokenParam := getOptional(continuationTokenUnescaped)
		var options *admin.DomainsClientListDomainWorkspacesOptions
		if continuationTokenParam != nil {
			options = &admin.DomainsClientListDomainWorkspacesOptions{
				ContinuationToken: continuationTokenParam,
			}
		}
		resp := d.srv.NewListDomainWorkspacesPager(domainIDParam, options)
		newListDomainWorkspacesPager = &resp
		d.newListDomainWorkspacesPager.add(req, newListDomainWorkspacesPager)
		server.PagerResponderInjectNextLinks(newListDomainWorkspacesPager, req, func(page *admin.DomainsClientListDomainWorkspacesResponse, createLink func() string) {
			page.ContinuationURI = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(newListDomainWorkspacesPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		d.newListDomainWorkspacesPager.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(newListDomainWorkspacesPager) {
		d.newListDomainWorkspacesPager.remove(req)
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchListDomains(req *http.Request) (*http.Response, error) {
	if d.srv.ListDomains == nil {
		return nil, &nonRetriableError{errors.New("fake for method ListDomains not implemented")}
	}
	qp := req.URL.Query()
	nonEmptyOnlyUnescaped, err := url.QueryUnescape(qp.Get("nonEmptyOnly"))
	if err != nil {
		return nil, err
	}
	nonEmptyOnlyParam, err := parseOptional(nonEmptyOnlyUnescaped, strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	var options *admin.DomainsClientListDomainsOptions
	if nonEmptyOnlyParam != nil {
		options = &admin.DomainsClientListDomainsOptions{
			NonEmptyOnly: nonEmptyOnlyParam,
		}
	}
	respr, errRespr := d.srv.ListDomains(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DomainsResponse, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchRoleAssignmentsBulkAssign(req *http.Request) (*http.Response, error) {
	if d.srv.RoleAssignmentsBulkAssign == nil {
		return nil, &nonRetriableError{errors.New("fake for method RoleAssignmentsBulkAssign not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/roleAssignments/bulkAssign`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.DomainRoleAssignmentRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.RoleAssignmentsBulkAssign(req.Context(), domainIDParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchRoleAssignmentsBulkUnassign(req *http.Request) (*http.Response, error) {
	if d.srv.RoleAssignmentsBulkUnassign == nil {
		return nil, &nonRetriableError{errors.New("fake for method RoleAssignmentsBulkUnassign not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/roleAssignments/bulkUnassign`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.DomainRoleUnassignmentRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.RoleAssignmentsBulkUnassign(req.Context(), domainIDParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchUnassignAllDomainWorkspaces(req *http.Request) (*http.Response, error) {
	if d.srv.UnassignAllDomainWorkspaces == nil {
		return nil, &nonRetriableError{errors.New("fake for method UnassignAllDomainWorkspaces not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/unassignAllWorkspaces`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.UnassignAllDomainWorkspaces(req.Context(), domainIDParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchUnassignDomainWorkspacesByIDs(req *http.Request) (*http.Response, error) {
	if d.srv.UnassignDomainWorkspacesByIDs == nil {
		return nil, &nonRetriableError{errors.New("fake for method UnassignDomainWorkspacesByIDs not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/unassignWorkspaces`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.UnassignDomainWorkspacesByIDsRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	var options *admin.DomainsClientUnassignDomainWorkspacesByIDsOptions
	if !reflect.ValueOf(body).IsZero() {
		options = &admin.DomainsClientUnassignDomainWorkspacesByIDsOptions{
			UnassignDomainWorkspacesByIDsRequest: &body,
		}
	}
	respr, errRespr := d.srv.UnassignDomainWorkspacesByIDs(req.Context(), domainIDParam, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (d *DomainsServerTransport) dispatchUpdateDomain(req *http.Request) (*http.Response, error) {
	if d.srv.UpdateDomain == nil {
		return nil, &nonRetriableError{errors.New("fake for method UpdateDomain not implemented")}
	}
	const regexStr = `/v1/admin/domains/(?P<domainId>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[admin.UpdateDomainRequest](req)
	if err != nil {
		return nil, err
	}
	domainIDParam, err := url.PathUnescape(matches[regex.SubexpIndex("domainId")])
	if err != nil {
		return nil, err
	}
	respr, errRespr := d.srv.UpdateDomain(req.Context(), domainIDParam, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Domain, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
